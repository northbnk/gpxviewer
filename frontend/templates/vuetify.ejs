<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>YamaMetri</title>
  <link href="https://cdn.jsdelivr.net/npm/vuetify@3.3.6/dist/vuetify.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/@mdi/font@7.x/css/materialdesignicons.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Material+Icons" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet">
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vuetify@3.3.6/dist/vuetify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vuetify@3.3.6/dist/vuetify-labs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    #map { height: 400px; }
    #chart { height: 150px; max-height: 400px; }
    .up1 { color: #6bc56b; }
    .up2 { color: #2e8b57; }
    .up3 { color: #006400; }
    .up4 { color: #004b00; }
    .up5 { color: #002b00; }
    .down1 { color: #e9967a; }
    .down2 { color: #cd5c5c; }
    .down3 { color: #8b0000; }
    .down4 { color: #7a0000; }
    .down5 { color: #3f0000; }
    .flat { color: #808080; }
    .material-symbols-outlined {
      font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
    }
    .group-table .v-data-table-footer__items-per-page,
    .group-table .v-data-table-footer__info,
    .estimated-table .v-data-table-footer__items-per-page,
    .estimated-table .v-data-table-footer__info,
    .perkm-table .v-data-table-footer__items-per-page,
    .perkm-table .v-data-table-footer__info,
    .split-table .v-data-table-footer__items-per-page,
    .split-table .v-data-table-footer__info {
      display: none;
    }
    .group-table .v-data-table-footer,
    .estimated-table .v-data-table-footer {
      display: none;
    }
    .v-data-table {
      border: 2px solid #e0e0e0;
      border-radius: 24px;
      overflow: hidden;
    }
    .v-data-table thead th {
      background: #f5f5fa;
      border-right: 1px solid #e0e0e0;
    }
    .v-data-table thead th:last-child {
      border-right: none;
    }
    .v-data-table tbody td {
      border-right: 1px solid #e0e0e0;
    }
    .v-data-table tbody td:last-child {
      border-right: none;
    }
    .editable-input {
      background-color: #fffbe6;
      max-width: 140px;
    }
    #waypointStats { overflow-x:auto; }
    #waypointStats table { width:100%; table-layout:fixed; border-collapse:collapse; }
    #waypointStats th { padding:2px 4px; text-align:right; }
    #waypointStats th.label-cell { text-align:left; font-weight:bold; width:120px; min-width:80px; }
    #waypointStats td { padding:2px 4px; text-align:right; }
    #waypointStats td.label-cell { text-align:left; font-weight:bold; }
    #waypointStats th:not(.label-cell), #waypointStats td:not(.label-cell) { text-align:center; }
    #waypointStats th:not(.label-cell), #waypointStats td:not(.label-cell) { width:auto; }
    #analysisText {
      max-width: 650px;
      margin: 32px auto 0 auto;
      border: 2px solid #e0e0e0;
      border-radius: 18px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.10), 0 1.5px 4px rgba(0,0,0,0.08);
      background: #fff;
      padding: 24px 28px;
    }
    .drop-area {
      padding: 16px;
      border-radius: 12px;
      border: 2px dashed #90caf9;
      transition: background 0.2s;
      min-height: 80px;
      margin-bottom: 8px;
    }
    .drop-area.dragover {
      background: rgba(144, 202, 249, 0.2);
    }
    .drop-panel {
      padding: 8px;
      border-radius: 16px;
      border: 2px dashed #bbb;
      transition: border-color 0.2s;
    }
    .drop-panel.drag-over {
      border-color: #1976d2 !important;
      background: #e3f2fd;
    }
  </style>
  <%- include('_favicon.ejs') %>
</head>
<body>
<div id="app">
  <v-app>
    <v-app-bar app color="primary" dark>
      <v-toolbar-title>
        <div class="pl-10">
          <img src="/assets/header.png" style="width:242px;height:50px;vertical-align:middle;margin-right:8px;">
        </div>
      </v-toolbar-title>
    </v-app-bar>
    <v-main>
      <v-container class="mt-4">
        <v-expansion-panels v-model="uploaderPanel">
          <v-expansion-panel>
            <v-expansion-panel-title expand-icon="mdi-chevron-down">GPXファイルアップロード</v-expansion-panel-title>
            <v-expansion-panel-text>
              <div
                class="drop-panel"
                :class="{ 'drag-over': isDragOver }"
                @dragover.prevent="onDragOver"
                @dragleave.prevent="onDragLeave"
                @drop.prevent="onDrop"
                style="padding: 8px; border-radius: 16px; border: 2px dashed #bbb; transition: border-color 0.2s;"
              >
                <div style="font-size: 15px; color: #666; margin-bottom: 8px;">
                  GPXファイルを選択またはドラッグ&ドロップでアップロードできます
                </div>
                <v-file-input label="GPX File" accept=".gpx" v-model="file" @change="onFileChange"></v-file-input>
                <v-btn color="primary" class="mt-2" @click="submit">アップロード</v-btn>
                <div v-if="isDragOver" style="color:#1976d2; font-weight:bold; margin-top:8px;">ここにGPXファイルをドロップ</div>
              </div>
            </v-expansion-panel-text>
          </v-expansion-panel>
          <v-expansion-panel>
            <v-expansion-panel-title expand-icon="mdi-chevron-down">保存・保存済みから開く</v-expansion-panel-title>
            <v-expansion-panel-text>
              <h3 class="mb-2">保存欄</h3>
              <v-row class="align-center mb-4" dense>
                <v-col>
                  <v-text-field v-model="title" label="タイトル"></v-text-field>
                </v-col>
                <v-col cols="auto">
                  <v-btn color="primary" @click="saveGpx">保存</v-btn>
                </v-col>
              </v-row>
              <v-divider class="my-2"></v-divider>
              <h3 class="mt-2 mb-1">保存済みGPXファイル一覧</h3>
              <v-list density="compact">
                <template v-for="(g, idx) in savedGpxList" :key="g.id">
                  <v-list-item>
                    <v-list-item-title>
                      <span v-if="editId !== g.id">{{ g.title || '(no title)' }}</span>
                      <v-text-field
                        v-else
                        v-model="editTitleTemp"
                        density="compact"
                        hide-details
                        class="editable-input"
                        style="max-width: 140px;"
                      ></v-text-field>
                    </v-list-item-title>
                    <v-list-item-subtitle>{{ g.name }} - {{ new Date(g.created).toLocaleString() }}</v-list-item-subtitle>
                    <template #append>
                      <v-btn size="small" class="mr-1" @click="toggleEdit(g)">{{ editId === g.id ? '保存' : '編集' }}</v-btn>
                      <v-btn size="small" class="mr-1" @click="deleteSaved(g)">削除</v-btn>
                      <v-btn size="small" @click="loadSavedGpx(g)">読み込む</v-btn>
                    </template>
                  </v-list-item>
                  <v-divider v-if="idx < savedGpxList.length - 1"></v-divider>
                </template>
                <v-list-item v-if="!savedGpxList.length">
                  <v-list-item-title>保存されたデータはありません</v-list-item-title>
                </v-list-item>
              </v-list>
            </v-expansion-panel-text>
        </v-expansion-panel>
      </v-expansion-panels>

      <v-dialog v-model="deleteDialog" width="400">
        <v-card>
          <v-card-title class="text-h6">削除しますか？</v-card-title>
          <v-card-actions>
            <v-spacer></v-spacer>
            <v-btn text @click="deleteDialog = false">キャンセル</v-btn>
            <v-btn color="red" text @click="confirmDelete">削除</v-btn>
          </v-card-actions>
        </v-card>
      </v-dialog>

      <div v-if="!stats.trackpoints || !stats.trackpoints.length" class="mt-6">
        <v-alert type="info" border="start" color="primary" variant="tonal">
          GPXファイルをアップロードしてください。
        </v-alert>
        </div>
        <div v-if="stats.trackpoints && stats.trackpoints.length" class="mt-6">
          <v-row>
            <v-col cols="12" sm="6" v-for="(value, key) in summaryStats" :key="key">
              <v-card>
                <v-card-title>{{ key }}</v-card-title>
                <v-card-text class="text-body-1">{{ value }}</v-card-text>
              </v-card>
            </v-col>
          </v-row>

          <v-tabs v-model="tab" class="mt-4 elevation-1" bg-color="grey-lighten-4" color="primary" ref="tabsTop">
            <v-tab :value="0">地図・高低差</v-tab>
            <v-tab :value="1">統計情報・予測</v-tab>
            <v-tab :value="2">AI分析</v-tab>
          </v-tabs>
          <v-window v-model="tab">
            <v-window-item :value="0" class="mt-4">
              <div class="pb-4 text-left">
                <span class="material-symbols-outlined" style="vertical-align:middle">info</span>
                <a href="#" @click.prevent="tab = 1" style="vertical-align:middle">統計情報やセグメント分析、予想ペースを詳しく見る</a>
              </div>
              <div id="map" class="mb-4"></div>
              <canvas id="chart"></canvas>
              <div class="mt-4">
                <v-btn color="primary" size="small" class="mb-2" @click="clearWaypoints">クリア</v-btn>
                <div id="waypointStats"></div>
              </div>
            </v-window-item>
            <v-window-item :value="1" class="mt-4">
              <h2>キロ区間分析</h2>
              <v-data-table :items="perKmData" :headers="perKmHeaders" class="mb-4 perkm-table" density="compact" @click:row="onKmRowClick">
                <template v-slot:item.trend="{ item }">
                  <span v-html="item.raw.trend"></span>
                </template>
              </v-data-table>
              <h2 class="mt-4">勾配グループ分析</h2>
              <v-data-table :items="summaryGroups" :headers="rateHeaders" class="mb-4 group-table" density="compact" hide-default-footer items-per-page="13">
                <template v-slot:item.trend="{ item }">
                  <span v-html="item.raw.trend"></span>
                </template>
                <template v-slot:item.avg_net_rate="{ item }">
                  {{ item.raw.avg_net_rate == null ? '-' : Number(item.raw.avg_net_rate).toFixed(2) }}
                </template>
                <template v-slot:item.avg_pace="{ item }">
                  {{ item.raw.avg_pace == null ? '-' : Number(item.raw.avg_pace).toFixed(2) }}
                </template>
              </v-data-table>
              <div class="d-flex mb-4">
                <v-btn color="primary" @click="downloadGroups">自身のペース分析ファイルをダウンロード</v-btn>
              </div>
              <h2 class="mt-4">想定ペース</h2>
              <v-data-table :items="predictedData" :headers="rateHeaders" class="mb-2 estimated-table" density="compact" hide-default-footer items-per-page="13">
                <template v-slot:item.trend="{ item }">
                  <span v-html="item.raw.trend"></span>
                </template>
                <template v-slot:item.avg_net_rate="{ item }">
                  {{ item.raw.avg_net_rate == null ? '-' : Number(item.raw.avg_net_rate).toFixed(2) }}
                </template>
                <template v-slot:item.avg_pace="{ item }">
                  <v-text-field v-model.number="item.raw.avg_pace" type="number" density="compact" hide-details class="editable-input" @change="computePredictedTimes"></v-text-field>
                </template>
              </v-data-table>
              <input type="file" ref="predFileInput" accept=".json" style="display:none" @change="onPredFileChange">
              <div class="d-flex mb-4">
                <v-row class="w-100" dense>
                  <v-col cols="12" sm="auto" class="mb-2 mb-sm-0">
                    <v-btn color="primary" @click="triggerPredUpload">自身のペース分析ファイルをアップロード</v-btn>
                  </v-col>
                  <v-col cols="12" sm="auto">
                    <v-btn color="primary" @click="computePredictedTimes">再計算</v-btn>
                  </v-col>
                </v-row>
              </div>
              <h2 class="mt-4">区間想定時間</h2>
              <v-data-table :items="splitTimes" :headers="splitHeaders" density="compact" class="split-table"></v-data-table>
            </v-window-item>
            <v-window-item :value="2" class="mt-4">
              <div>
                <v-btn color="primary" @click="generateAnalysis">レポートを生成する（あまりやりすぎると主にお金がかかるので控えめにお願いします！）</v-btn>
                <div v-if="analysisText" id="analysisText" class="mt-4 rounded-xl" v-html="analysisText"></div>
              </div>
            </v-window-item>
          </v-window>
        </div>
      </v-container>
    </v-main>
  </v-app>
</div>
<script>
const { createApp } = Vue;
let hoverLine = {
  id: 'hoverLine',
  afterDraw(chart) {
    const active = chart.getActiveElements && chart.getActiveElements();
    if (active && active.length) {
      const ctx = chart.ctx;
      const x = active[0].element.x;
      const topY = chart.scales.y.top;
      const bottomY = chart.scales.y.bottom;
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(x, topY);
      ctx.lineTo(x, bottomY);
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(0,0,0,0.4)';
      ctx.stroke();
      ctx.restore();
    }
  }
};
let rangeHighlight = {
  id: 'rangeHighlight',
  beforeDatasetsDraw(chart) {
    if (!chart._selectedRange) return;
    const { startIdx, endIdx } = chart._selectedRange;
    const meta = chart.getDatasetMeta(0);
    const ctx = chart.ctx;
    const startX = meta.data[startIdx].x;
    const endX = meta.data[endIdx].x;
    ctx.save();
    ctx.fillStyle = 'rgba(255,0,0,0.1)';
    ctx.fillRect(startX, chart.scales.y.top, endX - startX, chart.scales.y.bottom - chart.scales.y.top);
    ctx.restore();
  }
};
const vuetify = Vuetify.createVuetify({
  components: window.VuetifyLabs
    ? { ...Vuetify.components, ...VuetifyLabs.components }
    : Vuetify.components,
  directives: Vuetify.directives,
  theme: {
    defaultTheme: 'myTheme',
    themes: {
      myTheme: {
        dark: false,
        colors: {
          primary: '#5c6e82', // 青っぽいグレー
        }
      }
    }
  }
});
createApp({
  data() {
    return {
      file: null,
      stats: {},
      segmentSummary: null,
      predictedData: [],
      savedGpxList: [],
      splitTimes: [],
      map: null,
      chart: null,
      marker: null,
      startMarker: null,
      finishMarker: null,
      rangePolyline: null,
      trackPolylines: [],
      waypoints: [],
      wpMarkers: [],
      ranges: [
        { label: '-50% -    ', min: -Infinity, max: -50 },
        { label: '-50% - -40%', min: -50, max: -40 },
        { label: '-40% - -30%', min: -40, max: -30 },
        { label: '-30% - -20%', min: -30, max: -20 },
        { label: '-20% - -10%', min: -20, max: -10 },
        { label: '-10% - -5%', min: -10, max: -5 },
        { label: '-5%  -   5%', min: -5, max: 5 },
        { label: '5%  -  10%', min: 5, max: 10 },
        { label: '10% -  20%', min: 10, max: 20 },
        { label: '20% -  30%', min: 20, max: 30 },
        { label: '30% -  40%', min: 30, max: 40 },
        { label: '40% -  50%', min: 40, max: 50 },
        { label: '50% -    ', min: 50, max: Infinity }
      ],
      uploaderPanel: 0,
      tab: 0,
      analysisText: '',
      isDragOver: false,
      title: '',
      gpxId: null,
      deleteDialog: false,
      deleteTarget: null,
      editId: null,
      editTitleTemp: ''
      };
  },
  created() {
    this.loadPredicted();
    this.loadSavedList();
  },
  computed: {
    summaryStats() {
      if (!this.stats.trackpoints) return {};
      return {
        'トラックポイント数': this.stats.trackpoints.length,
        '総距離（km）': (this.stats.distance_m/1000).toFixed(2) + ' km',
        '最高標高': this.stats.highest_elevation_m.toFixed(1) + ' m',
        '最低標高': this.stats.lowest_elevation_m.toFixed(1) + ' m',
        '総獲得標高': this.stats.total_gain_m.toFixed(1) + ' m',
        '総標高損失': this.stats.total_loss_m.toFixed(1) + ' m'
      };
    },
    perKmData() { return this.stats.per_km_elevation || []; },
    rateGroups() { return this.segmentSummary ? this.segmentSummary.segments : []; },
    summaryGroups() { return this.segmentSummary ? this.segmentSummary.summary : []; },
    perKmHeaders() {
      return [
        { title: 'キロ', key: 'km' },
        { title: '上昇 (m)', key: 'gain' },
        { title: '降下 (m)', key: 'loss' },
        { title: '所要時間', key: 'actual_time' },
        { title: '予想時間', key: 'pred_time' },
        { title: '', key: 'trend', sortable: false }
      ];
    },
    rateHeaders() {
      return [
        { title: '', key: 'trend', sortable: false },
        { title: '勾配グループ', key: 'label' },
        { title: '平均上昇降下率(%)', key: 'avg_net_rate' },
        { title: '平均ペース (min/km)', key: 'avg_pace' }
      ];
    },
    segmentHeaders() {
      return [
        { title: 'キロ', key: 'km' },
        { title: '上昇降下率 (%)', key: 'net_rate' },
        { title: 'ペース (min/km)', key: 'pace_min_per_km' }
      ];
    },
    splitHeaders() {
      return [
        { title: '距離 (km)', key: 'distance' },
        { title: '予想時間', key: 'time' }
      ];
    }
  },
  watch: {
    tab(val) {
      this.scrollToTabs();
      if (val === 0) {
        this.$nextTick(() => {
          this.initMap();
          this.initChart();
          this.loadPredefinedWaypoints();
          this.updateSegments();
          this.updateWaypointDataset();
        });
      }
    },
    predictedData: {
      handler() {
        this.computePredictedTimes();
        this.savePredicted();
      },
      deep: true
    }
  },
  methods: {
    scrollToTabs() {
      this.$nextTick(() => {
        const el = this.$refs.tabsTop ? (this.$refs.tabsTop.$el || this.$refs.tabsTop) : null;
        if (el && el.getBoundingClientRect) {
          const top = el.getBoundingClientRect().top + window.pageYOffset;
          window.scrollTo({ top, behavior: 'smooth' });
        } else {
          window.scrollTo({ top: 0, behavior: 'smooth' });
        }
      });
    },
    savePredicted() {
      fetch('/api/predicted', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ data: this.predictedData })
      }).catch(() => {});
    },
    loadPredicted() {
      fetch('/api/predicted')
        .then(res => res.ok ? res.json() : Promise.reject())
        .then(json => {
          const data = json.data;
          if (Array.isArray(data)) {
            this.predictedData = data.map(r => ({
              ...r,
              avg_net_rate: r.avg_net_rate == null ? null : Number(r.avg_net_rate),
              avg_pace: r.avg_pace == null ? null : Number(r.avg_pace)
            }));
            this.addTrendInfo(this.predictedData);
            this.computePredictedTimes();
          }
        })
        .catch(() => {});
    },
    loadSavedList() {
      fetch('/api/gpx')
        .then(res => res.ok ? res.json() : Promise.reject())
        .then(json => { this.savedGpxList = Array.isArray(json.data) ? json.data : []; this.editId = null; })
        .catch(() => { this.savedGpxList = []; });
    },
    loadSavedGpx(g) {
      if (!g) return;
      fetch(`/api/gpx/${g.id}`)
        .then(res => res.ok ? res.json() : Promise.reject())
        .then(data => {
          this.applyStats(data);
          this.gpxId = g.id;
          this.title = g.title || '';
          this.uploaderPanel = null;
        })
        .catch(() => alert('Failed to load GPX'));
    },
    toggleEdit(g) {
      if (this.editId === g.id) {
        fetch(`/api/gpx/${g.id}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title: this.editTitleTemp })
        })
          .then(() => this.loadSavedList())
          .catch(() => {});
      } else {
        this.editId = g.id;
        this.editTitleTemp = g.title || '';
      }
    },
    deleteSaved(g) {
      this.deleteTarget = g;
      this.deleteDialog = true;
    },
    confirmDelete() {
      if (!this.deleteTarget) return;
      fetch(`/api/gpx/${this.deleteTarget.id}`, { method: 'DELETE' })
        .then(() => {
          this.loadSavedList();
          this.deleteDialog = false;
          this.deleteTarget = null;
        })
        .catch((err) => {
          console.error(err);
          this.deleteDialog = false;
        });
    },
    applyStats(data) {
      if (!data || !data.stats) {
        alert('Failed to load GPX');
        return;
      }
      this.stats = data.stats;
      this.segmentSummary = data.segmentSummary;
      if (this.segmentSummary && this.segmentSummary.summary) {
        this.segmentSummary.summary.forEach(r => {
          r.avg_net_rate = r.avg_net_rate == null ? null : Number(r.avg_net_rate);
          r.avg_pace = r.avg_pace == null ? null : Number(r.avg_pace);
        });
      }
      if (this.segmentSummary && this.segmentSummary.segments) {
        this.segmentSummary.segments.forEach(s => {
          s.net_rate = s.net_rate == null ? null : Number(s.net_rate);
          s.pace_min_per_km = s.pace_min_per_km == null ? null : Number(s.pace_min_per_km);
        });
      }
      this.predictedData = JSON.parse(JSON.stringify(this.segmentSummary?.summary || []));
      this.predictedData.forEach(r => {
        r.avg_net_rate = r.avg_net_rate == null ? null : Number(r.avg_net_rate);
        r.avg_pace = r.avg_pace == null ? null : Number(r.avg_pace);
      });
      this.addTrendInfo(this.stats.per_km_elevation);
      if (this.segmentSummary && this.segmentSummary.summary) this.addTrendInfo(this.segmentSummary.summary);
      this.addTrendInfo(this.predictedData);
      this.computePredictedTimes();
      this.waypoints = [];
      this.wpMarkers.forEach(m => m.setMap(null));
      this.wpMarkers = [];
      this.$nextTick(() => {
        this.initMap();
        this.initChart();
        this.loadPredefinedWaypoints();
        this.updateSegments();
        this.updateWaypointDataset();
      });
    },
    saveGpx() {
      const file = Array.isArray(this.file) ? this.file[0] : this.file;
      if (!this.gpxId) {
        if (!file) return;
        const formData = new FormData();
        formData.append('gpxfile', file);
        formData.append('title', this.title);
        fetch('/api/upload', { method: 'POST', body: formData })
          .then(res => res.ok ? res.json() : Promise.reject())
          .then(data => {
            this.applyStats(data);
            this.gpxId = data.id;
            this.loadSavedList();
            this.uploaderPanel = null;
            this.title = '';
            this.file = null;
          })
          .catch(() => alert('Failed to parse GPX'));
      } else {
        fetch(`/api/gpx/${this.gpxId}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title: this.title })
        })
          .then(() => this.loadSavedList())
          .catch(() => {});
      }
    },
    parseFile() {
      const file = Array.isArray(this.file) ? this.file[0] : this.file;
      if (!file) return;
      const formData = new FormData();
      formData.append('gpxfile', file);
      fetch('/api/parse', { method: 'POST', body: formData })
        .then(res => res.ok ? res.json() : Promise.reject())
        .then(data => {
          this.applyStats(data);
          this.gpxId = null;
        })
        .catch(() => alert('Failed to parse GPX'));
    },
    downloadPredicted() {
      const blob = new Blob([JSON.stringify(this.predictedData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'rate_groups.json';
      a.click();
      URL.revokeObjectURL(url);
    },
    triggerPredUpload() {
      this.$refs.predFileInput.click();
    },
    onPredFileChange(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const data = JSON.parse(reader.result);
          if (Array.isArray(data)) {
            this.predictedData = data.map(r => ({
              ...r,
              avg_net_rate: r.avg_net_rate == null ? null : Number(r.avg_net_rate),
              avg_pace: r.avg_pace == null ? null : Number(r.avg_pace)
            }));
            this.addTrendInfo(this.predictedData);
          }
        } catch (err) {
          alert('Invalid JSON');
        }
        this.computePredictedTimes();
        this.$refs.predFileInput.value = '';
      };
      reader.readAsText(file);
    },
    downloadGroups() {
      const blob = new Blob([JSON.stringify(this.summaryGroups, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'rate_groups.json';
      a.click();
      URL.revokeObjectURL(url);
    },
    slopeColor(rate) {
    if (rate > 8) return '#B000FF'; // ビビッドパープル（紫）
    if (rate > 5) return '#FF0033'; // ビビッドレッド
    if (rate > 2) return '#FF8000'; // 蛍光オレンジ
    if (rate > 1) return '#FFFF00'; // 蛍光イエロー
    if (rate >= -1) return '#00FFFF'; // 蛍光ブルー（水色）
    if (rate > -5) return '#0080FF'; // ビビッドブルー
    if (rate > -8) return '#00FFCC'; // 蛍光シアン
    return '#0099FF';
    },
    initMap() {
      const mapDiv = document.getElementById('map');
      if (!mapDiv) return;
      if (!this.stats.trackpoints || !this.stats.trackpoints.length || !window.google) return;
      if (this.startMarker) { this.startMarker.setMap(null); this.startMarker = null; }
      if (this.finishMarker) { this.finishMarker.setMap(null); this.finishMarker = null; }
      this.trackPolylines.forEach(p => p.setMap(null));
      this.trackPolylines = [];
      const path = this.stats.trackpoints.map(p => ({ lat: p[0], lng: p[1] }));
      this.map = Vue.markRaw(new google.maps.Map(mapDiv, {
        zoom: 14,
        center: path[0],
        zoomControl: true,
        scrollwheel: true,
        gestureHandling: 'greedy',
        mapTypeId: 'terrain'
      }));
      const bounds = new google.maps.LatLngBounds();
      path.forEach(p => bounds.extend(p));
      this.map.fitBounds(bounds);
      // Group multiple points into a single colored segment to avoid creating
      // thousands of individual polylines which can slow down rendering.
      // Use smaller segments so the color changes are more fine grained
      const step = 5; // number of points per segment
      const segments = [];
      for (let i = 0; i < this.stats.trackpoints.length - 1; i += step) {
        const startIdx = i;
        const endIdx = Math.min(i + step, this.stats.trackpoints.length - 1);
        const start = this.stats.trackpoints[startIdx];
        const end = this.stats.trackpoints[endIdx];
        const dist = end[4] - start[4];
        const diff = (end[2] != null && start[2] != null) ? end[2] - start[2] : 0;
        const rate = dist > 0 ? (diff / dist) * 100 : 0;
        const color = this.slopeColor(rate);
        const segPath = [];
        for (let j = startIdx; j <= endIdx; j++) {
          segPath.push({ lat: this.stats.trackpoints[j][0], lng: this.stats.trackpoints[j][1] });
        }
        segments.push({ path: segPath, color });
      }
      segments.forEach(seg => {
        const poly = new google.maps.Polyline({
          path: seg.path,
          map: this.map,
          strokeColor: seg.color,
          strokeOpacity: 1,
          strokeWeight: 6
        });
        poly.addListener('mousemove', e => {
          const idx = this.nearestIndex(e.latLng.lat(), e.latLng.lng());
          this.updateHighlight(idx);
        });
        poly.addListener('click', e => {
          const idx = this.nearestIndex(e.latLng.lat(), e.latLng.lng());
          this.addWaypoint(idx);
        });
        this.trackPolylines.push(poly);
      });
      this.marker = Vue.markRaw(new google.maps.Marker({ map: this.map }));
      this.startMarker = Vue.markRaw(new google.maps.Marker({ position: path[0], map: this.map, label: 'S' }));
      this.finishMarker = Vue.markRaw(new google.maps.Marker({ position: path[path.length - 1], map: this.map, label: 'F' }));
      this.map.addListener('mousemove', e => {
        const idx = this.nearestIndex(e.latLng.lat(), e.latLng.lng());
        this.updateHighlight(idx);
      });
      this.map.addListener('click', e => {
        const idx = this.nearestIndex(e.latLng.lat(), e.latLng.lng());
        this.addWaypoint(idx);
      });
      if (this.stats.waypoints) {
        this.stats.waypoints.forEach(wp => {
          new google.maps.Marker({ position: { lat: wp.lat, lng: wp.lon }, map: this.map, title: wp.name || '' });
        });
      }
    },
    initChart() {
      let chartEl = document.getElementById('chart');
      if (!chartEl) return;
      if (this.chart) {
        this.chart.destroy();
        const newEl = chartEl.cloneNode(true);
        chartEl.parentNode.replaceChild(newEl, chartEl);
        chartEl = newEl;
      }
      const ctx = chartEl.getContext('2d');
      // Chart.jsに渡すデータはVueのreactiveからdeep copyで非リアクティブ化
      const rawProfile = JSON.parse(JSON.stringify(this.stats.profile));
      const labels = rawProfile.map(p => (p[0] / 1000).toFixed(1));
      const elev = rawProfile.map(p => p[1]);
      Chart.register(hoverLine, rangeHighlight);
      const self = this;
      this.chart = Vue.markRaw(new Chart(ctx, {
        type: 'line',
        data: { labels, datasets: [{ label: 'Elevation', data: elev, borderColor: 'blue', fill: false, pointRadius: 0 }] },
        options: {
          responsive: true,
          interaction: { mode: 'nearest', intersect: false },
          scales: { x: { title: { display: true, text: 'Distance (km)' } }, y: { title: { display: true, text: 'Elevation (m)' } } },
          plugins: {
            tooltip: {
              callbacks: {
                title: ctx => {
                  if (!ctx.length) return '';
                  const idx = ctx[0].dataIndex;
                  const distKm = (self.stats.trackpoints[idx][4] / 1000).toFixed(2);
                  return `Distance: ${distKm} km`;
                },
                label: ctx => {
                  const idx = ctx.dataIndex;
                  const ele = self.stats.trackpoints[idx][2];
                  const lines = [`Elevation: ${ele != null ? ele.toFixed(1) : 'N/A'} m`];
                  const prev = self.lastWaypointIndex(idx);
                  if (prev < idx) {
                    const stats = self.computeStats(prev, idx);
                    if (stats) {
                      lines.push(`Gain: ${stats.gain_m.toFixed(1)} m`);
                      lines.push(`Loss: ${stats.loss_m.toFixed(1)} m`);
                      const dist = stats.dist_m;
                      const inc = dist > 0 ? ((self.stats.trackpoints[idx][2] - self.stats.trackpoints[prev][2]) / dist * 100).toFixed(2) : '0.00';
                      lines.push(`Inclination: ${inc} %`);
                    }
                  }
                  return lines;
                }
              }
            }
          }
        },
        plugins: [hoverLine, rangeHighlight]
      }));
      document.getElementById('chart').addEventListener('mousemove', evt => {
        const els = this.chart.getElementsAtEventForMode(evt, 'nearest', { intersect: false }, false);
        if (els.length) this.updateHighlight(els[0].index);
      });
      document.getElementById('chart').addEventListener('click', evt => {
        const els = this.chart.getElementsAtEventForMode(evt, 'nearest', { intersect: false }, false);
        if (els.length) this.addWaypoint(els[0].index);
      });
    },
    formatTime(sec) {
      if (sec == null) return '-';
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      const s = Math.round(sec % 60);
      return (h ? h + 'h ' : '') + m + 'm ' + s + 's';
    },
    predictedTimeSeconds(dist, netRate) {
      if (!this.predictedData || !this.predictedData.length) return null;
      const slope = netRate;
      const range = this.ranges.find(r => slope >= r.min && slope < r.max);
      if (!range) return null;
      const grp = this.predictedData.find(g => g.label === range.label);
      if (!grp || grp.avg_pace == null) return null;
      return (dist / 1000) * grp.avg_pace * 60;
    },
    predictedTime(dist, netRate) {
      const sec = this.predictedTimeSeconds(dist, netRate);
      return this.formatTime(sec);
    },
    lastWaypointIndex(idx) {
      let prev = 0;
      for (let i = 0; i < this.waypoints.length; i++) {
        if (this.waypoints[i] >= idx) break;
        prev = this.waypoints[i];
      }
      return prev;
    },
    addTrendInfo(arr) {
      if (!arr) return;
      arr.forEach(row => {
        let diff;
        if (row.gain != null && row.loss != null) {
          diff = row.gain - row.loss;
        } else if (row.avg_net_rate != null) {
          diff = row.avg_net_rate;
        } else {
          const r = this.ranges.find(v => v.label === row.label);
          if (r) {
            if (r.max <= -5) diff = -11;
            else if (r.min >= 5) diff = 11;
            else diff = 0;
          }
        }
        let icon, cls;
        if (diff > 10) {
          icon = 'trending_up';
          if (diff > 50) cls = 'up5';
          else if (diff > 40) cls = 'up4';
          else if (diff > 30) cls = 'up3';
          else if (diff > 20) cls = 'up2';
          else cls = 'up1';
        } else if (diff < -10) {
          icon = 'trending_down';
          if (diff < -50) cls = 'down5';
          else if (diff < -40) cls = 'down4';
          else if (diff < -30) cls = 'down3';
          else if (diff < -20) cls = 'down2';
          else cls = 'down1';
        } else {
          icon = 'trending_flat';
          cls = 'flat';
        }
        row.trend = `<span class="${cls} material-symbols-outlined">${icon}</span>`;
      });
    },
    computePredictedTimes() {
      if (!this.stats.trackpoints) return;
      const pts = this.stats.trackpoints;
      (this.stats.per_km_elevation || []).forEach(row => {
        if (row.start_idx != null && row.end_idx != null) {
          const dist = pts[row.end_idx][4] - pts[row.start_idx][4];
          const avgUp = dist > 0 ? (row.gain / dist) * 100 : 0;
          const avgDown = dist > 0 ? (row.loss / dist) * 100 : 0;
          const net = avgUp - avgDown;
          row.actual_time_s = row.duration_s;
          row.pred_time_s = this.predictedTimeSeconds(dist, net);
          row.actual_time = this.formatTime(row.actual_time_s);
          row.pred_time = this.formatTime(row.pred_time_s);
        }
      });
      this.splitTimes = [];
      let cum = 0;
      (this.stats.per_km_elevation || []).forEach((row, idx) => {
        if (row.pred_time_s != null) cum += row.pred_time_s;
        if ((idx + 1) % 5 === 0) {
          this.splitTimes.push({ distance: `${idx + 1} km`, time: this.formatTime(cum) });
        }
      });
      this.splitTimes.push({ distance: 'Finish', time: this.formatTime(cum) });
    },
    nearestIndex(lat, lng) {
      let best = 0;
      let bestDist = Infinity;
      const pts = this.stats.trackpoints || [];
      for (let i = 0; i < pts.length; i++) {
        const dLat = pts[i][0] - lat;
        const dLng = pts[i][1] - lng;
        const d = dLat * dLat + dLng * dLng;
        if (d < bestDist) { bestDist = d; best = i; }
      }
      return best;
    },
    updateHighlight(idx) {
      if (!this.stats.trackpoints || !this.stats.trackpoints[idx]) return;
      if (this.marker) {
        this.marker.setPosition({ lat: this.stats.trackpoints[idx][0], lng: this.stats.trackpoints[idx][1] });
      }
      if (this.chart) {
        this.chart.setActiveElements([{ datasetIndex: 0, index: idx }]);
        this.chart.tooltip.setActiveElements([{ datasetIndex: 0, index: idx }]);
        this.chart.update();
      }
    },
    highlightRange(startIdx, endIdx) {
      if (!this.chart) return;
      this.chart._selectedRange = { startIdx, endIdx };
      this.chart.update();
      if (this.map) {
        const path = [];
        for (let i = startIdx; i <= endIdx; i++) {
          path.push({ lat: this.stats.trackpoints[i][0], lng: this.stats.trackpoints[i][1] });
        }
        if (!this.rangePolyline) {
          this.rangePolyline = Vue.markRaw(new google.maps.Polyline({
            path,
            map: this.map,
            strokeColor: 'red',
            strokeOpacity: 0.8,
            strokeWeight: 6
          }));
        } else {
          this.rangePolyline.setPath(path);
          this.rangePolyline.setMap(this.map);
        }
      }
    },
    computeStats(startIdx, endIdx) {
      if (endIdx <= startIdx) return null;
      const pts = this.stats.trackpoints;
      const dist = pts[endIdx][4] - pts[startIdx][4];
      let gain = 0, loss = 0;
      for (let i = startIdx + 1; i <= endIdx; i++) {
        const diff = pts[i][2] - pts[i-1][2];
        if (diff > 0) gain += diff; else if (diff < 0) loss += -diff;
      }
      const avgUp = dist > 0 ? (gain / dist) * 100 : 0;
      const avgDown = dist > 0 ? (loss / dist) * 100 : 0;
      const netRate = avgUp - avgDown;
      const pred = this.formatTime(this.predictedTimeSeconds(dist, netRate));
      return { dist_m: dist, gain_m: gain, loss_m: loss, avg_up: avgUp, avg_down: avgDown, pred_time: pred };
    },
    buildWaypointSegments() {
      const idxs = [0, ...this.waypoints, this.stats.trackpoints.length - 1].sort((a,b) => a - b);
      const segs = [];
      for (let i = 0; i < idxs.length - 1; i++) {
        const stats = this.computeStats(idxs[i], idxs[i+1]);
        if (stats) segs.push(Object.assign({ idx: i + 1 }, stats));
      }
      return segs;
    },
    updateSegments() {
      const segs = this.buildWaypointSegments();
      const container = document.getElementById('waypointStats');
      if (!container) return;
      container.innerHTML = '';
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const headRow = document.createElement('tr');
      headRow.innerHTML = '<th class="label-cell">区間：</th>';
      segs.forEach((seg, i) => {
        const startLabel = i === 0 ? 'Start' : `WP${i}`;
        const endLabel = i === segs.length - 1 ? 'Finish' : `WP${i+1}`;
        headRow.innerHTML += `<th class="text-right">${startLabel}-${endLabel}</th>`;
      });
      thead.appendChild(headRow);
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      const rows = [
        { label: '距離：', format: seg => `${(seg.dist_m/1000).toFixed(1)} km` },
        { label: '上昇(m)：', format: seg => `${seg.gain_m.toFixed(1)} m` },
        { label: '降下(m)：', format: seg => `${seg.loss_m.toFixed(1)} m` },
        { label: '平均上昇率：', format: seg => `${seg.avg_up.toFixed(2)} %` },
        { label: '平均下降率：', format: seg => `${seg.avg_down.toFixed(2)} %` }
      ];
      rows.forEach(info => {
        const row = document.createElement('tr');
        row.innerHTML = `<td class="label-cell">${info.label}</td>` + segs.map(seg => `<td class="text-right">${info.format(seg)}</td>`).join('');
        tbody.appendChild(row);
      });
      table.appendChild(tbody);
      container.appendChild(table);
    },
    updateWaypointDataset() {
      if (!this.chart || !this.stats.profile) return;
      const data = this.stats.profile.map((p, idx) => this.waypoints.includes(idx) ? p[1] : null);
      if (this.chart.data.datasets.length === 1) {
        this.chart.data.datasets.push({ label: 'Waypoints', data, borderColor: 'red', backgroundColor: 'red', showLine: false, pointRadius: 4 });
      } else {
        this.chart.data.datasets[1].data = data;
      }
      this.chart.update();
    },
    loadPredefinedWaypoints() {
      (this.stats.waypoints || []).forEach(wp => {
        const idx = this.nearestIndex(wp.lat, wp.lon);
        this.addWaypoint(idx);
      });
    },
    addWaypoint(idx) {
      if (idx <= 0 || idx >= this.stats.trackpoints.length - 1) return;
      if (!this.waypoints.includes(idx)) {
        this.waypoints.push(idx);
        this.waypoints.sort((a,b) => a-b);
        if (this.map) {
          const marker = Vue.markRaw(new google.maps.Marker({ position: { lat: this.stats.trackpoints[idx][0], lng: this.stats.trackpoints[idx][1] }, map: this.map, label: String(this.waypoints.indexOf(idx)+1) }));
          this.wpMarkers.push(marker);
        }
        this.updateSegments();
        this.updateWaypointDataset();
      }
    },
    clearWaypoints() {
      this.waypoints = [];
      this.wpMarkers.forEach(m => m.setMap(null));
      this.wpMarkers = [];
      this.updateSegments();
      this.updateWaypointDataset();
    },
    generateAnalysis() {
      this.analysisText = 'Generating...';
      fetch('/generate-analysis', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ stats: this.stats })
      })
        .then(res => res.ok ? res.json() : Promise.reject())
        .then(data => {
          if (data.text) this.analysisText = marked.parse(data.text);
          else this.analysisText = 'Failed to generate';
        })
        .catch(() => { this.analysisText = 'Error generating analysis'; });
    },
    onKmRowClick(_e, row) {
      if (row.start_idx != null && row.end_idx != null) {
        this.highlightRange(row.start_idx, row.end_idx);
      }
    },
    onDragOver() {
      this.isDragOver = true;
    },
    onDragLeave() {
      this.isDragOver = false;
    },
    onDrop(e) {
      this.isDragOver = false;
      const files = e.dataTransfer.files;
      if (files && files.length > 0) {
        this.file = files[0];
        this.parseFile();
      }
    },
    onFileChange() {
      const file = Array.isArray(this.file) ? this.file[0] : this.file;
      if (file) {
        this.parseFile();
      }
    },
    // ...existing code...
  }
}).use(vuetify).mount('#app');
</script>
<% if (googleMapsApiKey) { %>
<script async defer src="https://maps.googleapis.com/maps/api/js?key=<%= googleMapsApiKey %>"></script>
<% } %>
</body>
</html>
