<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>GPX Result</title>
  <link href="https://unpkg.com/tabulator-tables@5.4.4/dist/css/tabulator.min.css" rel="stylesheet">
  <style>
    .up1 { color: #6bc56b; }
    .up2 { color: #2e8b57; }
    .up3 { color: #006400; }
    .down1 { color: #e9967a; }
    .down2 { color: #cd5c5c; }
    .down3 { color: #8b0000; }
    .flat { color: #808080; }
  </style>
</head>
<body>
  <h1>GPX Analysis</h1>
  <% if (stats.points) { %>
  <p>Total trackpoints: <%= stats.points %></p>
  <p>Total distance: <%= stats.distance_m.toFixed(1) %> meters</p>
  <p>Highest elevation: <%= stats.highest_elevation_m != null ? stats.highest_elevation_m.toFixed(1) : 'N/A' %> m</p>
  <p>Lowest elevation: <%= stats.lowest_elevation_m != null ? stats.lowest_elevation_m.toFixed(1) : 'N/A' %> m</p>
  <p>Total gain: <%= stats.total_gain_m.toFixed(1) %> m</p>
  <p>Total loss: <%= stats.total_loss_m.toFixed(1) %> m</p>
  <p>Uphill threshold: <%= slopeData.up_threshold %>% - time: <%= slopeData.up_time_s.toFixed(1) %> s</p>
  <p>Downhill threshold: <%= slopeData.down_threshold %>% - time: <%= slopeData.down_time_s.toFixed(1) %> s</p>
  <button id="downloadBtn">Download analysis JSON</button>
  <div id="layout" style="display:flex;align-items:flex-start;gap:10px;">
    <div id="left-panel">
      <h2>Track</h2>
      <div id="map" style="width:900px;height:450px;border:1px solid #ccc"></div>
      <h2>Elevation Profile</h2>
      <label for="yScale">Y-Axis Max:</label>
      <select id="yScale">
        <% const initY = Math.min(3000, Math.max(500, Math.ceil((stats.highest_elevation_m || 0) / 500) * 500)); %>
        <% for (let v = 500; v <= 3000; v += 500) { %>
          <option value="<%= v %>" <%= v === initY ? 'selected' : '' %>><%= v %>m</option>
        <% } %>
      </select>
      <canvas id="elevChart" width="900" height="450"></canvas>
    </div>
    <div id="right-panel">
      <div style="display:flex;gap:10px;">
        <div>
          <h2>Elevation per KM</h2>
          <div id="perKmTable" style="width:300px;"></div>
        </div>
        <div>
          <h2>Rate Groups</h2>
          <div id="segmentTable" style="width:300px;"></div>
        </div>
      </div>
    </div>
  </div>
  <script>
    const points = <%- JSON.stringify(stats.trackpoints || []) %>;
    const profile = <%- JSON.stringify(stats.profile || []) %>;
    const perKmData = <%- JSON.stringify(stats.per_km_elevation || []) %>;
    const slopeData = <%- JSON.stringify(slopeData || {}) %>;
    const segmentData = <%- JSON.stringify(segmentSummary || {}) %>;
    perKmData.forEach(row => {
      const diff = row.gain - row.loss;
      let arrow, cls;
      if (diff > 5) {
        arrow = '↑';
        if (diff > 40) cls = 'up3';
        else if (diff > 20) cls = 'up2';
        else cls = 'up1';
      } else if (diff < -5) {
        arrow = '↓';
        if (diff < -40) cls = 'down3';
        else if (diff < -20) cls = 'down2';
        else cls = 'down1';
      } else {
        arrow = '→';
        cls = 'flat';
      }
      row.trend = `<span class="${cls}">${arrow}</span>`;
    });
  </script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://unpkg.com/tabulator-tables@5.4.4/dist/js/tabulator.min.js"></script>
  <script>
    let chart, map, marker;
    const hoverLine = {
      id: 'hoverLine',
      afterDraw(chart) {
        if (chart.tooltip && chart.tooltip._active && chart.tooltip._active.length) {
          const ctx = chart.ctx;
          const x = chart.tooltip._active[0].element.x;
          const topY = chart.scales.y.top;
          const bottomY = chart.scales.y.bottom;
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(x, topY);
          ctx.lineTo(x, bottomY);
          ctx.lineWidth = 1;
          ctx.strokeStyle = 'rgba(0,0,0,0.4)';
          ctx.stroke();
          ctx.restore();
        }
      }
    };

    function updateHighlight(idx) {
      if (!points[idx]) return;
      if (marker) {
        marker.setPosition({ lat: points[idx][0], lng: points[idx][1] });
      }
      if (chart) {
        chart.setActiveElements([{ datasetIndex: 0, index: idx }]);
        chart.tooltip.setActiveElements([{ datasetIndex: 0, index: idx }]);
        chart.update();
      }
    }

    function nearestIndex(lat, lng) {
      let best = 0;
      let bestDist = Infinity;
      for (let i = 0; i < points.length; i++) {
        const dLat = points[i][0] - lat;
        const dLng = points[i][1] - lng;
        const d = dLat * dLat + dLng * dLng;
        if (d < bestDist) { bestDist = d; best = i; }
      }
      return best;
    }

    function createMap() {
      if (!points.length) return;
      const path = points.map(p => ({ lat: p[0], lng: p[1] }));
      map = new google.maps.Map(document.getElementById('map'), {
        zoom: 14,
        center: path[0],
        zoomControl: true,
        scrollwheel: true,
        gestureHandling: 'greedy'
      });
      const bounds = new google.maps.LatLngBounds();
      path.forEach(p => bounds.extend(p));
      map.fitBounds(bounds);
      const poly = new google.maps.Polyline({ path, map, strokeColor: 'blue' });
      marker = new google.maps.Marker({ map });
      map.addListener('mousemove', e => {
        const idx = nearestIndex(e.latLng.lat(), e.latLng.lng());
        updateHighlight(idx);
      });
      poly.addListener('mousemove', e => {
        const idx = nearestIndex(e.latLng.lat(), e.latLng.lng());
        updateHighlight(idx);
      });
    }

    function initChart() {
      if (profile.length < 2) return;
      const ctx = document.getElementById('elevChart').getContext('2d');
      const labels = profile.map(p => (p[0] / 1000).toFixed(2));
      const elev = profile.map(p => p[1]);
      const yMax = parseInt(document.getElementById('yScale').value, 10);
      Chart.register(hoverLine);
      chart = new Chart(ctx, {
        type: 'line',
        data: { labels, datasets: [{ label: 'Elevation (m)', data: elev, borderColor: 'blue', fill: false, pointRadius: 0 }] },
        options: {
          interaction: { mode: 'nearest', intersect: false },
          scales: { x: { title: { display: true, text: 'Distance (km)' } }, y: { title: { display: true, text: 'Elevation (m)' }, min: 0, max: yMax } },
          responsive: false,
          maintainAspectRatio: false
        },
        plugins: [hoverLine]
      });
      document.getElementById('yScale').addEventListener('change', e => {
        const newMax = parseInt(e.target.value, 10);
        chart.options.scales.y.max = newMax;
        chart.update();
      });
      document.getElementById('elevChart').addEventListener('mousemove', evt => {
        const els = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: false }, false);
        if (els.length) updateHighlight(els[0].index);
      });
    }

    function initTable() {
      if (perKmData && perKmData.length) {
        new Tabulator('#perKmTable', {
          data: perKmData,
          layout: 'fitColumns',
          columns: [
            { title: '', field: 'trend', formatter: 'html', hozAlign: 'center', width: 40 },
            { title: 'KM', field: 'km' },
            { title: 'Gain (m)', field: 'gain', formatter: cell => cell.getValue().toFixed(1) },
            { title: 'Loss (m)', field: 'loss', formatter: cell => cell.getValue().toFixed(1) }
          ]
        });
      }
      if (segmentData && segmentData.summary) {
        new Tabulator('#segmentTable', {
          data: segmentData.summary,
          layout: 'fitColumns',
          columns: [
            { title: 'Group', field: 'label' },
            { title: 'Avg Net Rate (%)', field: 'avg_net_rate', formatter: cell => cell.getValue() == null ? '-' : cell.getValue().toFixed(2) },
            { title: 'Avg Speed (km/h)', field: 'avg_speed', formatter: cell => cell.getValue() == null ? '-' : cell.getValue().toFixed(2) }
          ]
        });
      }
    }

  window.initMap = function() {
    createMap();
    initChart();
    initTable();
  };

  document.getElementById('downloadBtn').addEventListener('click', function() {
    const blob = new Blob([JSON.stringify(slopeData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'slope_analysis.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  });
</script>
<% if (googleMapsApiKey) { %>
<script async defer src="https://maps.googleapis.com/maps/api/js?key=<%= googleMapsApiKey %>&callback=initMap"></script>
<% } else { %>
<p style="color:red">Google Maps API key not set</p>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    initChart();
    initTable();
  });
</script>
<% } %>
  <% } else { %>
  <p>No trackpoints found in GPX.</p>
  <% } %>
  <a href="/">Upload another file</a>
</body>
</html>
