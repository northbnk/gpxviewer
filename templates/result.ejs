<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>GPX Result</title>
  <link href="https://unpkg.com/tabulator-tables@5.4.4/dist/css/tabulator.min.css" rel="stylesheet">
  <style>
    .up1 { color: #6bc56b; }
    .up2 { color: #2e8b57; }
    .up3 { color: #006400; }
    .down1 { color: #e9967a; }
    .down2 { color: #cd5c5c; }
    .down3 { color: #8b0000; }
    .flat { color: #808080; }
    .trend-icon { font-weight:bold; }
    .stats-grid { display:flex; gap:40px; flex-wrap:wrap; margin-bottom:10px; width:900px; }
    .stats-col { flex:1; min-width:200px; line-height:1.2; }
    .stat-row { display:flex; justify-content:space-between; margin:2px 0; }
    .stat-label { flex:1; font-weight: bold; }
    .stat-value { margin-left:10px; text-align:right; min-width:70px; }
    #waypointStats { overflow-x:auto; }
    #waypointStats table { width:100%; table-layout:fixed; border-collapse:collapse; }
    #waypointStats th, #waypointStats td { padding:2px 4px; text-align:center; }
    #waypointStats td.label-cell, #waypointStats th.label-cell { text-align:left; font-weight:bold; }
  </style>
</head>
<body>
  <div style="display:flex;align-items:center;gap:10px;">
    <h1 style="margin:0;">GPX Analysis</h1>
    <form id="uploadFormTop" action="/upload" method="post" enctype="multipart/form-data" style="margin:0;">
      <div id="dropZoneTop" style="width:150px;height:40px;border:2px dashed #aaa;display:flex;align-items:center;justify-content:center;font-size:0.9em;cursor:pointer;">
        Drop GPX here
      </div>
      <input type="file" id="fileInputTop" name="gpxfile" accept=".gpx" style="display:none">
    </form>
  </div>
  <% if (stats.points) { %>
  <div class="stats-grid">
    <div class="stats-col">
      <div class="stat-row"><span class="stat-label">Total trackpoints:</span><span class="stat-value"><%= stats.points %></span></div>
      <div class="stat-row"><span class="stat-label">Total distance:</span><span class="stat-value"><%= (stats.distance_m/1000).toFixed(1) %> km</span></div>
      <div class="stat-row"><span class="stat-label">Highest elevation:</span><span class="stat-value"><%= stats.highest_elevation_m != null ? stats.highest_elevation_m.toFixed(1) : 'N/A' %> m</span></div>
    </div>
    <div class="stats-col">
      <div class="stat-row"><span class="stat-label">Lowest elevation:</span><span class="stat-value"><%= stats.lowest_elevation_m != null ? stats.lowest_elevation_m.toFixed(1) : 'N/A' %> m</span></div>
      <div class="stat-row"><span class="stat-label">Total gain:</span><span class="stat-value"><%= stats.total_gain_m.toFixed(1) %> m</span></div>
      <div class="stat-row"><span class="stat-label">Total loss:</span><span class="stat-value"><%= stats.total_loss_m.toFixed(1) %> m</span></div>
    </div>
  </div>
  <div id="layout" style="display:flex;align-items:flex-start;gap:10px;">
    <div id="left-panel">
      <h2>Track</h2>
      <div id="map" style="width:900px;height:450px;border:1px solid #ccc"></div>
      <h2>Elevation Profile</h2>
      <label for="yScale">Elevation Max:</label>
      <select id="yScale">
        <% const initY = Math.min(3000, Math.max(500, Math.ceil((stats.highest_elevation_m || 0) / 500) * 500)); %>
        <% for (let v = 500; v <= 3000; v += 500) { %>
          <option value="<%= v %>" <%= v === initY ? 'selected' : '' %>><%= v %>m</option>
        <% } %>
      </select>
      <canvas id="elevChart" width="900" height="450"></canvas>
      <div>
        <h2>Waypoints</h2>
        <button id="clearWaypointsBtn">Clear</button>
        <div id="waypointStats"></div>
      </div>
    </div>
    <div id="right-panel">
      <div style="display:flex;gap:10px;">
        <div>
          <h2>Elevation per KM</h2>
          <div id="perKmTable" style="width:545px;height:980px;"></div>
        </div>
        <div>
          <h2>Rate Groups</h2>
          <div id="segmentTable" style="width:460px;"></div>
          <button id="downloadRateBtn">Download JSON</button>
          <h2 style="margin-top:20px;">Estimated Rate</h2>
          <div id="predTable" style="width:460px;"></div>
          <input type="file" id="rateFileInput" accept=".json" style="display:none">
          <button id="uploadRateBtn">Upload JSON</button>
        </div>
      </div>
      </div>
    </div>
  <script>
    const points = <%- JSON.stringify(stats.trackpoints || []) %>;
    const profile = <%- JSON.stringify(stats.profile || []) %>;
    const perKmData = <%- JSON.stringify(stats.per_km_elevation || []) %>;
    const segmentData = <%- JSON.stringify(segmentSummary || {}) %>;
    const predictedData = JSON.parse(JSON.stringify(segmentData.summary || []));
    perKmData.forEach(row => {
      const diff = row.gain - row.loss;
      let arrow, cls;
      if (diff > 5) {
        arrow = '↑';
        if (diff > 40) cls = 'up3';
        else if (diff > 20) cls = 'up2';
        else cls = 'up1';
      } else if (diff < -5) {
        arrow = '↓';
        if (diff < -40) cls = 'down3';
        else if (diff < -20) cls = 'down2';
        else cls = 'down1';
      } else {
        arrow = '→';
        cls = 'flat';
      }
      row.trend = `<span class="${cls} trend-icon"><b>${arrow}</b></span>`;
      if (row.start_idx != null && row.end_idx != null) {
        const dist = points[row.end_idx][4] - points[row.start_idx][4];
        const up = row.gain;
        const down = row.loss;
        const avgUp = dist > 0 ? (up / dist) * 100 : 0;
        const avgDown = dist > 0 ? (down / dist) * 100 : 0;
        const net = avgUp - avgDown;
        row.actual_time_s = row.duration_s;
        row.pred_time_s = predictedTimeSeconds(dist, net);
      }
    });
  </script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://unpkg.com/tabulator-tables@5.4.4/dist/js/tabulator.min.js"></script>
  <script>
    let chart, map, marker;
    const hoverLine = {
      id: 'hoverLine',
      afterDraw(chart) {
        if (chart.tooltip && chart.tooltip._active && chart.tooltip._active.length) {
          const ctx = chart.ctx;
          const x = chart.tooltip._active[0].element.x;
          const topY = chart.scales.y.top;
          const bottomY = chart.scales.y.bottom;
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(x, topY);
          ctx.lineTo(x, bottomY);
          ctx.lineWidth = 1;
          ctx.strokeStyle = 'rgba(0,0,0,0.4)';
          ctx.stroke();
          ctx.restore();
        }
      }
    };

    const rangeHighlight = {
      id: 'rangeHighlight',
      beforeDatasetsDraw(chart) {
        if (!chart._selectedRange) return;
        const { startIdx, endIdx } = chart._selectedRange;
        const meta = chart.getDatasetMeta(0);
        const ctx = chart.ctx;
        const startX = meta.data[startIdx].x;
        const endX = meta.data[endIdx].x;
        ctx.save();
        ctx.fillStyle = 'rgba(255,0,0,0.1)';
        ctx.fillRect(startX, chart.scales.y.top, endX - startX, chart.scales.y.bottom - chart.scales.y.top);
        ctx.restore();
      }
    };

    function updateHighlight(idx) {
      if (!points[idx]) return;
      if (marker) {
        marker.setPosition({ lat: points[idx][0], lng: points[idx][1] });
      }
      if (chart) {
        chart.setActiveElements([{ datasetIndex: 0, index: idx }]);
        chart.tooltip.setActiveElements([{ datasetIndex: 0, index: idx }]);
        chart.update();
      }
    }

    function highlightRange(startIdx, endIdx) {
      if (!chart) return;
      chart._selectedRange = { startIdx, endIdx };
      chart.update();
    }

    function nearestIndex(lat, lng) {
      let best = 0;
      let bestDist = Infinity;
      for (let i = 0; i < points.length; i++) {
        const dLat = points[i][0] - lat;
        const dLng = points[i][1] - lng;
        const d = dLat * dLat + dLng * dLng;
        if (d < bestDist) { bestDist = d; best = i; }
      }
      return best;
    }

    function createMap() {
      if (!points.length) return;
      const path = points.map(p => ({ lat: p[0], lng: p[1] }));
      map = new google.maps.Map(document.getElementById('map'), {
        zoom: 14,
        center: path[0],
        zoomControl: true,
        scrollwheel: true,
        gestureHandling: 'greedy'
      });
      const bounds = new google.maps.LatLngBounds();
      path.forEach(p => bounds.extend(p));
      map.fitBounds(bounds);
      const poly = new google.maps.Polyline({ path, map, strokeColor: 'blue' });
      marker = new google.maps.Marker({ map });
      map.addListener('mousemove', e => {
        const idx = nearestIndex(e.latLng.lat(), e.latLng.lng());
        updateHighlight(idx);
      });
      poly.addListener('mousemove', e => {
        const idx = nearestIndex(e.latLng.lat(), e.latLng.lng());
        updateHighlight(idx);
      });
      map.addListener('click', e => {
        const idx = nearestIndex(e.latLng.lat(), e.latLng.lng());
        addWaypoint(idx);
      });
      poly.addListener('click', e => {
        const idx = nearestIndex(e.latLng.lat(), e.latLng.lng());
        addWaypoint(idx);
      });
    }

    function initChart() {
      if (profile.length < 2) return;
      const ctx = document.getElementById('elevChart').getContext('2d');
      const labels = profile.map(p => (p[0] / 1000).toFixed(1));
      const elev = profile.map(p => p[1]);
      const yMax = parseInt(document.getElementById('yScale').value, 10);
      Chart.register(hoverLine);
      Chart.register(rangeHighlight);
      chart = new Chart(ctx, {
        type: 'line',
        data: { labels, datasets: [{ label: 'Elevation (m)', data: elev, borderColor: 'blue', fill: false, pointRadius: 0 }] },
        options: {
          interaction: { mode: 'nearest', intersect: false },
          scales: { x: { title: { display: true, text: 'Distance (km)' } }, y: { title: { display: true, text: 'Elevation (m)' }, min: 0, max: yMax } },
          responsive: false,
          maintainAspectRatio: false
        },
        plugins: [hoverLine, rangeHighlight]
      });
      document.getElementById('yScale').addEventListener('change', e => {
        const newMax = parseInt(e.target.value, 10);
        chart.options.scales.y.max = newMax;
        chart.update();
      });
      document.getElementById('elevChart').addEventListener('mousemove', evt => {
        const els = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: false }, false);
        if (els.length) updateHighlight(els[0].index);
      });
      document.getElementById('elevChart').addEventListener('click', evt => {
        const els = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: false }, false);
        if (els.length) addWaypoint(els[0].index);
      });
      updateWaypointDataset();
    }

    let perKmTable, segTable, predTable;

    function initTable() {
      if (perKmData && perKmData.length) {
        perKmTable = new Tabulator('#perKmTable', {
          data: perKmData,
          layout: 'fitColumns',
          rowClick: (e, row) => {
            const d = row.getData();
            if (d.start_idx != null && d.end_idx != null) {
              highlightRange(d.start_idx, d.end_idx);
            }
          },
          columns: [
            { title: 'KM', field: 'km', width: 50 },
            { title: 'Gain (m)', field: 'gain', width: 70, formatter: cell => cell.getValue().toFixed(1) },
            { title: 'Loss (m)', field: 'loss', width: 70, formatter: cell => cell.getValue().toFixed(1) },
            { title: 'Actual Time', field: 'actual_time_s', width: 132, formatter: cell => formatTime(cell.getValue()) },
            { title: 'Estimated Time', field: 'pred_time_s', width: 158, formatter: cell => formatTime(cell.getValue()) },
            { title: '', field: 'trend', formatter: 'html', hozAlign: 'center', width: 50 }
          ]
        });
      }
      if (segmentData && segmentData.summary) {
        segTable = new Tabulator('#segmentTable', {
          data: segmentData.summary,
          layout: 'fitColumns',
          columns: [
            { title: 'Group', field: 'label', width: 100 },
            { title: 'Avg Net Rate (%)', field: 'avg_net_rate', width: 180, formatter: cell => cell.getValue() == null ? '-' : cell.getValue().toFixed(2) },
            { title: 'Avg Speed (km/h)', field: 'avg_speed', width: 180, formatter: cell => cell.getValue() == null ? '-' : cell.getValue().toFixed(2) }
          ]
        });
      }
      if (predictedData) {
        predTable = new Tabulator('#predTable', {
          data: predictedData,
          layout: 'fitColumns',
          columns: [
            { title: 'Group', field: 'label', editor: false, width: 100 },
            { title: 'Avg Net Rate (%)', field: 'avg_net_rate', width: 180, editor: 'number', editorParams: { step: 0.01 } },
            { title: 'Avg Speed (km/h)', field: 'avg_speed', width: 180, editor: 'number', editorParams: { step: 0.01 } }
          ],
          cellEdited: computePredictedTimes
        });
      }
      computePredictedTimes();
    }

    const ranges = [
      { label: '[0%  -  5%]', min: 0, max: 5 },
      { label: '[5%  - 10%]', min: 5, max: 10 },
      { label: '[10% - 15%]', min: 10, max: 15 },
      { label: '[15% - 20%]', min: 15, max: 20 },
      { label: '[20% -    ]', min: 20, max: Infinity }
    ];
    let waypoints = [];
    let wpMarkers = [];

    function formatTime(sec) {
      if (sec == null) return '-';
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      const s = Math.round(sec % 60);
      return (h ? h + 'h ' : '') + m + 'm ' + s + 's';
    }

    function predictedTimeSeconds(dist, netRate) {
      if (!predictedData || !predictedData.length) return null;
      const slope = Math.max(0, netRate);
      const range = ranges.find(r => slope >= r.min && slope < r.max);
      if (!range) return null;
      const grp = predictedData.find(g => g.label === range.label);
      if (!grp || grp.avg_speed == null) return null;
      return (dist / 1000) / grp.avg_speed * 3600;
    }

    function predictedTime(dist, netRate) {
      const sec = predictedTimeSeconds(dist, netRate);
      return formatTime(sec);
    }

    function computePredictedTimes() {
      perKmData.forEach(row => {
        if (row.start_idx != null && row.end_idx != null) {
          const dist = points[row.end_idx][4] - points[row.start_idx][4];
          const avgUp = dist > 0 ? (row.gain / dist) * 100 : 0;
          const avgDown = dist > 0 ? (row.loss / dist) * 100 : 0;
          const net = avgUp - avgDown;
          row.pred_time_s = predictedTimeSeconds(dist, net);
        }
      });
      if (perKmTable) perKmTable.replaceData(perKmData);
    }

    function computeStats(startIdx, endIdx) {
      if (endIdx <= startIdx) return null;
      const dist = points[endIdx][4] - points[startIdx][4];
      let gain = 0, loss = 0;
      for (let i = startIdx + 1; i <= endIdx; i++) {
        const diff = points[i][2] - points[i-1][2];
        if (diff > 0) gain += diff; else if (diff < 0) loss += -diff;
      }
      const avgUp = dist > 0 ? (gain / dist) * 100 : 0;
      const avgDown = dist > 0 ? (loss / dist) * 100 : 0;
      const netRate = avgUp - avgDown;
      const pred = predictedTime(dist, netRate);
      return { dist_m: dist, gain_m: gain, loss_m: loss, avg_up: avgUp, avg_down: avgDown, pred_time: pred };
    }

    function updateSegments() {
      const idxs = [0, ...waypoints, points.length - 1];
      idxs.sort((a,b) => a-b);
      const segs = [];
      for (let i = 0; i < idxs.length - 1; i++) {
        const st = idxs[i];
        const en = idxs[i+1];
        const stats = computeStats(st, en);
        if (stats) segs.push(Object.assign({ idx: i + 1 }, stats));
      }

      const container = document.getElementById('waypointStats');
      container.innerHTML = '';

      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const headRow = document.createElement('tr');
      headRow.innerHTML = '<th class="label-cell">Name</th>';
      segs.forEach((seg, i) => {
        const startLabel = i === 0 ? 'Start' : `WP${i}`;
        const endLabel = i === segs.length - 1 ? 'Finish' : `WP${i+1}`;
        headRow.innerHTML += `<th>${startLabel}-${endLabel}</th>`;
      });
      thead.appendChild(headRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      function addRow(label, formatter) {
        const row = document.createElement('tr');
        row.innerHTML = `<td class="label-cell">${label}</td>`;
        segs.forEach(seg => {
          row.innerHTML += `<td>${formatter(seg)}</td>`;
        });
        tbody.appendChild(row);
      }

      addRow('Distance', seg => `${(seg.dist_m/1000).toFixed(1)} km`);
      addRow('Elevation Gain', seg => `${seg.gain_m.toFixed(1)} m`);
      addRow('Elevation Loss', seg => `${seg.loss_m.toFixed(1)} m`);
      addRow('Average Up', seg => `${seg.avg_up.toFixed(2)} %`);
      addRow('Average Down', seg => `${seg.avg_down.toFixed(2)} %`);

      table.appendChild(tbody);
      container.appendChild(table);
    }

    function updateWaypointDataset() {
      if (!chart) return;
      const data = profile.map((p, idx) => waypoints.includes(idx) ? p[1] : null);
      if (chart.data.datasets.length === 1) {
        chart.data.datasets.push({ label: 'Waypoints', data, borderColor: 'red', backgroundColor: 'red', showLine: false, pointRadius: 4 });
      } else {
        chart.data.datasets[1].data = data;
      }
      chart.update();
    }

    function addWaypoint(idx) {
      if (idx <= 0 || idx >= points.length - 1) return;
      if (!waypoints.includes(idx)) {
        waypoints.push(idx);
        waypoints.sort((a,b) => a-b);
        if (map) {
          const marker = new google.maps.Marker({ position: { lat: points[idx][0], lng: points[idx][1] }, map, label: String(waypoints.indexOf(idx)+1) });
          wpMarkers.push(marker);
        }
        updateSegments();
        updateWaypointDataset();
      }
    }

    document.getElementById('clearWaypointsBtn').addEventListener('click', () => {
      waypoints = [];
      wpMarkers.forEach(m => m.setMap(null));
      wpMarkers = [];
      updateSegments();
      updateWaypointDataset();
    });

  window.initMap = function() {
    createMap();
    initChart();
    initTable();
    updateSegments();
    updateWaypointDataset();
  };

  document.getElementById('downloadRateBtn').addEventListener('click', function() {
    const blob = new Blob([JSON.stringify(segmentData.summary, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'rate_groups.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  });

  document.getElementById('uploadRateBtn').addEventListener('click', function() {
    document.getElementById('rateFileInput').click();
  });

  document.getElementById('rateFileInput').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function() {
      try {
        const data = JSON.parse(reader.result);
        if (Array.isArray(data)) {
          predictedData.splice(0, predictedData.length, ...data);
          if (predTable) predTable.replaceData(predictedData);
          computePredictedTimes();
        }
      } catch(err) {
        alert('Invalid JSON');
      }
    };
    reader.readAsText(file);
    this.value = '';
  });

  // Top drop zone upload
  const dropZoneTop = document.getElementById('dropZoneTop');
  const fileInputTop = document.getElementById('fileInputTop');
  const uploadFormTop = document.getElementById('uploadFormTop');

  dropZoneTop.addEventListener('click', () => fileInputTop.click());
  dropZoneTop.addEventListener('dragover', e => {
    e.preventDefault();
    dropZoneTop.style.background = '#f0f0f0';
  });
  dropZoneTop.addEventListener('dragleave', () => {
    dropZoneTop.style.background = '';
  });
  dropZoneTop.addEventListener('drop', e => {
    e.preventDefault();
    dropZoneTop.style.background = '';
    if (e.dataTransfer.files && e.dataTransfer.files.length) {
      fileInputTop.files = e.dataTransfer.files;
      uploadFormTop.submit();
    }
  });
  fileInputTop.addEventListener('change', () => {
    if (fileInputTop.files.length) uploadFormTop.submit();
  });

</script>
<% if (googleMapsApiKey) { %>
<script async defer src="https://maps.googleapis.com/maps/api/js?key=<%= googleMapsApiKey %>&callback=initMap"></script>
<% } else { %>
<p style="color:red">Google Maps API key not set</p>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    initChart();
    initTable();
  });
</script>
<% } %>
  <% } else { %>
  <p>No trackpoints found in GPX.</p>
  <% } %>
</body>
</html>
