<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>GPX Result</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://unpkg.com/tabulator-tables@5.4.4/dist/css/tabulator.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet">
  <style>
    .up1 { color: #6bc56b; }
    .up2 { color: #2e8b57; }
    .up3 { color: #006400; }
    .down1 { color: #e9967a; }
    .down2 { color: #cd5c5c; }
    .down3 { color: #8b0000; }
    .flat { color: #808080; }
    .material-symbols-outlined {
      font-variation-settings: 'FILL' 1, 'wght' 400, 'GRAD' 0, 'opsz' 24;
    }
    .trend-icon.material-symbols-outlined {
      font-size: 1.4em;
      vertical-align: middle;
    }
    .stats-grid { display:flex; gap:40px; flex-wrap:wrap; margin-bottom:10px; width:100%; max-width:900px; }
    #layout { display:flex; align-items:flex-start; gap:10px; flex-wrap:wrap; }
    #left-panel, #right-panel { flex:1 1 500px; }
    #map { width:100%; max-width:900px; height:450px; }
    #elevChart { width:100%; max-width:900px; height:auto; }
    #perKmTable { width:100%; max-width:545px; height:980px; }
    #segmentTable, #predTable, #splitTimesTable { width:100%; max-width:510px; }
    .right-inner { display:flex; gap:10px; flex-wrap:wrap; }
    .stats-col { flex:1; min-width:200px; line-height:1.2; }
    .stat-row { display:flex; justify-content:space-between; margin:2px 0; }
    .stat-label { flex:1; font-weight: bold; }
    .stat-value { margin-left:10px; text-align:right; min-width:70px; }
    #waypointStats { overflow-x:auto; }
    #waypointStats table { width:100%; table-layout:fixed; border-collapse:collapse; }
    #waypointStats th { padding:2px 4px; text-align:right; }
    #waypointStats td { padding:2px 4px; text-align:right; }
    #waypointStats td.label-cell { text-align:left; font-weight:bold; }
    #waypointStats th.label-cell { text-align:left; font-weight:bold; }
  </style>
</head>
<body>
  <div style="display:flex;align-items:center;gap:10px;">
    <h1 style="margin:0;">GPX Analysis</h1>
    <form id="uploadFormTop" action="/upload" method="post" enctype="multipart/form-data" style="margin:0;">
      <div id="dropZoneTop" style="width:150px;height:40px;border:2px dashed #aaa;display:flex;align-items:center;justify-content:center;font-size:0.9em;cursor:pointer;">
        Drop GPX here
      </div>
      <input type="file" id="fileInputTop" name="gpxfile" accept=".gpx" style="display:none">
    </form>
  </div>
  <% if (stats.points) { %>
  <div class="stats-grid">
    <div class="stats-col">
      <div class="stat-row"><span class="stat-label">Total trackpoints:</span><span class="stat-value"><%= stats.points %></span></div>
      <div class="stat-row"><span class="stat-label">Total distance:</span><span class="stat-value"><%= (stats.distance_m/1000).toFixed(1) %> km</span></div>
      <div class="stat-row"><span class="stat-label">Highest elevation:</span><span class="stat-value"><%= stats.highest_elevation_m != null ? stats.highest_elevation_m.toFixed(1) : 'N/A' %> m</span></div>
    </div>
    <div class="stats-col">
      <div class="stat-row"><span class="stat-label">Lowest elevation:</span><span class="stat-value"><%= stats.lowest_elevation_m != null ? stats.lowest_elevation_m.toFixed(1) : 'N/A' %> m</span></div>
      <div class="stat-row"><span class="stat-label">Total gain:</span><span class="stat-value"><%= stats.total_gain_m.toFixed(1) %> m</span></div>
      <div class="stat-row"><span class="stat-label">Total loss:</span><span class="stat-value"><%= stats.total_loss_m.toFixed(1) %> m</span></div>
    </div>
  </div>
  <div id="layout">
    <div id="left-panel">
      <h2>Track</h2>
      <div id="map" style="border:1px solid #ccc; height:450px;"></div>
      <h2>Elevation Profile</h2>
      <label for="yScale">Elevation Max:</label>
      <select id="yScale">
        <% const initY = Math.min(3000, Math.max(500, Math.ceil((stats.highest_elevation_m || 0) / 500) * 500)); %>
        <% for (let v = 500; v <= 3000; v += 500) { %>
          <option value="<%= v %>" <%= v === initY ? 'selected' : '' %>><%= v %>m</option>
        <% } %>
      </select>
      <canvas id="elevChart" width="900" height="450"></canvas>
    </div>
    <div id="right-panel">
      <div class="right-inner">
        <div>
          <h2>Elevation per KM</h2>
          <div id="perKmTable" style="height:980px;"></div>
        </div>
        <div>
          <h2>Rate Groups</h2>
          <div id="segmentTable"></div>
          <button id="downloadRateBtn">Download JSON</button>
          <h2 style="margin-top:20px;">Estimated Rate</h2>
          <div id="predTable"></div>
          <input type="file" id="rateFileInput" accept=".json" style="display:none">
          <div style="margin-top:5px;display:flex;gap:5px;align-items:center;">
            <button id="uploadRateBtn">Upload JSON</button>
            <button id="refreshRateBtn">Refresh</button>
          </div>
          <div id="splitTimesTable" style="margin-top:10px;"></div>
        </div>
      </div>
    </div>
  </div>

  <div id="waypointsSection" style="width:100%;margin-top:20px;">
    <h2>Waypoints</h2>
    <button id="clearWaypointsBtn">Clear</button>
    <div id="waypointStats"></div>
  </div>
  <script>
    const points = <%- JSON.stringify(stats.trackpoints || []) %>;
    const profile = <%- JSON.stringify(stats.profile || []) %>;
    const perKmData = <%- JSON.stringify(stats.per_km_elevation || []) %>;
    const segmentData = <%- JSON.stringify(segmentSummary || {}) %>;
    const predictedData = JSON.parse(JSON.stringify(segmentData.summary || []));

    function addTrendInfo(arr) {
      arr.forEach(row => {
        const diff = (row.gain && row.loss) != null ? (row.gain - row.loss) : row.avg_net_rate;
        let icon, cls;
        if (diff > 5) {
          icon = 'trending_up';
          if (diff > 40) cls = 'up3';
          else if (diff > 20) cls = 'up2';
          else cls = 'up1';
        } else if (diff < -5) {
          icon = 'trending_down';
          if (diff < -40) cls = 'down3';
          else if (diff < -20) cls = 'down2';
          else cls = 'down1';
        } else {
          icon = 'trending_flat';
          cls = 'flat';
        }
        row.trend = `<span class="${cls} material-symbols-outlined trend-icon">${icon}</span>`;
      });
    }

    addTrendInfo(perKmData);
    if (segmentData.summary) addTrendInfo(segmentData.summary);
    addTrendInfo(predictedData);
  </script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://unpkg.com/tabulator-tables@5.4.4/dist/js/tabulator.min.js"></script>
  <script>
    let chart, map, marker, rangePolyline;
    const hoverLine = {
      id: 'hoverLine',
      afterDraw(chart) {
        if (chart.tooltip && chart.tooltip._active && chart.tooltip._active.length) {
          const ctx = chart.ctx;
          const x = chart.tooltip._active[0].element.x;
          const topY = chart.scales.y.top;
          const bottomY = chart.scales.y.bottom;
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(x, topY);
          ctx.lineTo(x, bottomY);
          ctx.lineWidth = 1;
          ctx.strokeStyle = 'rgba(0,0,0,0.4)';
          ctx.stroke();
          ctx.restore();
        }
      }
    };

    const rangeHighlight = {
      id: 'rangeHighlight',
      beforeDatasetsDraw(chart) {
        if (!chart._selectedRange) return;
        const { startIdx, endIdx } = chart._selectedRange;
        const meta = chart.getDatasetMeta(0);
        const ctx = chart.ctx;
        const startX = meta.data[startIdx].x;
        const endX = meta.data[endIdx].x;
        ctx.save();
        ctx.fillStyle = 'rgba(255,0,0,0.1)';
        ctx.fillRect(startX, chart.scales.y.top, endX - startX, chart.scales.y.bottom - chart.scales.y.top);
        ctx.restore();
      }
    };

    function updateHighlight(idx) {
      if (!points[idx]) return;
      if (marker) {
        marker.setPosition({ lat: points[idx][0], lng: points[idx][1] });
      }
      if (chart) {
        chart.setActiveElements([{ datasetIndex: 0, index: idx }]);
        chart.tooltip.setActiveElements([{ datasetIndex: 0, index: idx }]);
        chart.update();
      }
    }

    function highlightRange(startIdx, endIdx) {
      if (!chart) return;
      chart._selectedRange = { startIdx, endIdx };
      chart.update();
      if (map) {
        const path = [];
        for (let i = startIdx; i <= endIdx; i++) {
          path.push({ lat: points[i][0], lng: points[i][1] });
        }
        if (!rangePolyline) {
          rangePolyline = new google.maps.Polyline({
            path,
            map,
            strokeColor: 'red',
            strokeOpacity: 0.8,
            strokeWeight: 6
          });
        } else {
          rangePolyline.setPath(path);
          rangePolyline.setMap(map);
        }
      }
    }

    function nearestIndex(lat, lng) {
      let best = 0;
      let bestDist = Infinity;
      for (let i = 0; i < points.length; i++) {
        const dLat = points[i][0] - lat;
        const dLng = points[i][1] - lng;
        const d = dLat * dLat + dLng * dLng;
        if (d < bestDist) { bestDist = d; best = i; }
      }
      return best;
    }

    function createMap() {
      if (!points.length) return;
      const path = points.map(p => ({ lat: p[0], lng: p[1] }));
      map = new google.maps.Map(document.getElementById('map'), {
        zoom: 14,
        center: path[0],
        zoomControl: true,
        scrollwheel: true,
        gestureHandling: 'greedy',
        mapTypeId: 'terrain'
      });
      const bounds = new google.maps.LatLngBounds();
      path.forEach(p => bounds.extend(p));
      map.fitBounds(bounds);
      const poly = new google.maps.Polyline({ path, map, strokeColor: 'blue' });
      marker = new google.maps.Marker({ map });
      map.addListener('mousemove', e => {
        const idx = nearestIndex(e.latLng.lat(), e.latLng.lng());
        updateHighlight(idx);
      });
      poly.addListener('mousemove', e => {
        const idx = nearestIndex(e.latLng.lat(), e.latLng.lng());
        updateHighlight(idx);
      });
      map.addListener('click', e => {
        const idx = nearestIndex(e.latLng.lat(), e.latLng.lng());
        addWaypoint(idx);
      });
      poly.addListener('click', e => {
        const idx = nearestIndex(e.latLng.lat(), e.latLng.lng());
        addWaypoint(idx);
      });
    }

    function initChart() {
      if (profile.length < 2) return;
      const ctx = document.getElementById('elevChart').getContext('2d');
      const labels = profile.map(p => (p[0] / 1000).toFixed(1));
      const elev = profile.map(p => p[1]);
      const yMax = parseInt(document.getElementById('yScale').value, 10);
      Chart.register(hoverLine);
      Chart.register(rangeHighlight);
      chart = new Chart(ctx, {
        type: 'line',
        data: { labels, datasets: [{ label: 'Elevation (m)', data: elev, borderColor: 'blue', fill: false, pointRadius: 0 }] },
        options: {
          interaction: { mode: 'nearest', intersect: false },
          scales: { x: { title: { display: true, text: 'Distance (km)' } }, y: { title: { display: true, text: 'Elevation (m)' }, min: 0, max: yMax } },
          responsive: false,
          maintainAspectRatio: false,
          plugins: {
            tooltip: {
              callbacks: {
                title: ctx => {
                  if (!ctx.length) return '';
                  const idx = ctx[0].dataIndex;
                  const distKm = (points[idx][4] / 1000).toFixed(2);
                  return `Distance: ${distKm} km`;
                },
                label: ctx => {
                  const idx = ctx.dataIndex;
                  const ele = points[idx][2];
                  const lines = [`Elevation: ${ele != null ? ele.toFixed(1) : 'N/A'} m`];
                  const prev = lastWaypointIndex(idx);
                  if (prev < idx) {
                    const stats = computeStats(prev, idx);
                    if (stats) {
                      lines.push(`Gain: ${stats.gain_m.toFixed(1)} m`);
                      lines.push(`Loss: ${stats.loss_m.toFixed(1)} m`);
                      const dist = stats.dist_m;
                      const inc = dist > 0 ? ((points[idx][2] - points[prev][2]) / dist * 100).toFixed(2) : '0.00';
                      lines.push(`Inclination: ${inc} %`);
                    }
                  }
                  return lines;
                }
              }
            }
          }
        },
        plugins: [hoverLine, rangeHighlight]
      });
      document.getElementById('yScale').addEventListener('change', e => {
        const newMax = parseInt(e.target.value, 10);
        chart.options.scales.y.max = newMax;
        chart.update();
      });
      document.getElementById('elevChart').addEventListener('mousemove', evt => {
        const els = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: false }, false);
        if (els.length) updateHighlight(els[0].index);
      });
      document.getElementById('elevChart').addEventListener('click', evt => {
        const els = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: false }, false);
        if (els.length) addWaypoint(els[0].index);
      });
      updateWaypointDataset();
    }

    let perKmTable, segTable, predTable, splitTimesTable;

    function initTable() {
      if (perKmData && perKmData.length) {
        perKmTable = new Tabulator('#perKmTable', {
          data: perKmData,
          layout: 'fitColumns',
          rowClick: (e, row) => {
            const d = row.getData();
            if (d.start_idx != null && d.end_idx != null) {
              highlightRange(d.start_idx, d.end_idx);
            }
          },
          columns: [
            { title: 'KM', field: 'km', width: 50, hozAlign: 'right' },
            { title: 'Gain (m)', field: 'gain', width: 70, hozAlign: 'right', formatter: cell => cell.getValue().toFixed(1) },
            { title: 'Loss (m)', field: 'loss', width: 70, hozAlign: 'right', formatter: cell => cell.getValue().toFixed(1) },
            { title: 'Actual Time', field: 'actual_time_s', width: 132, hozAlign: 'right', formatter: cell => formatTime(cell.getValue()) },
            { title: 'Estimated Time', field: 'pred_time_s', width: 158, hozAlign: 'right', formatter: cell => formatTime(cell.getValue()) },
            { title: '', field: 'trend', formatter: 'html', hozAlign: 'center', width: 50 }
          ]
        });
      }
      if (segmentData && segmentData.summary) {
        segTable = new Tabulator('#segmentTable', {
          data: segmentData.summary,
          layout: 'fitColumns',
          columns: [
            { title: '', field: 'trend', formatter: 'html', hozAlign: 'center', width: 50 },
            { title: 'Group', field: 'label', width: 100 },
            { title: 'Avg Net Rate (%)', field: 'avg_net_rate', width: 180, hozAlign: 'right', formatter: cell => cell.getValue() == null ? '-' : cell.getValue().toFixed(2) },
            { title: 'Avg Pace (min/km)', field: 'avg_pace', width: 180, hozAlign: 'right', formatter: cell => cell.getValue() == null ? '-' : cell.getValue().toFixed(2) }
          ]
        });
      }
      if (predictedData) {
        predTable = new Tabulator('#predTable', {
          data: predictedData,
          layout: 'fitColumns',
          columns: [
            { title: '', field: 'trend', formatter: 'html', hozAlign: 'center', width: 50 },
            { title: 'Group', field: 'label', editor: false, width: 100 },
            { title: 'Avg Net Rate (%)', field: 'avg_net_rate', width: 180, hozAlign: 'right', editor: 'number', editorParams: { step: 0.01 }, formatter: cell => cell.getValue() == null ? '-' : Number(cell.getValue()).toFixed(2) },
            { title: 'Avg Pace (min/km)', field: 'avg_pace', width: 180, hozAlign: 'right', editor: 'number', editorParams: { step: 0.01 }, formatter: cell => cell.getValue() == null ? '-' : Number(cell.getValue()).toFixed(2) }
          ],
          cellEdited: computePredictedTimes
        });
      }
      computePredictedTimes();
    }

    const ranges = [
      { label: '[-40% -    ]', min: -Infinity, max: -40 },
      { label: '[-20% - -40%]', min: -40, max: -20 },
      { label: '[ -5% - -20%]', min: -20, max: -5 },
      { label: '[-5%  -   5%]', min: -5, max: 5 },
      { label: '[5%  -  20%]', min: 5, max: 20 },
      { label: '[20% -  40%]', min: 20, max: 40 },
      { label: '[40% -    ]', min: 40, max: Infinity }
    ];
    let waypoints = [];
    let wpMarkers = [];

    function lastWaypointIndex(idx) {
      let prev = 0;
      for (let i = 0; i < waypoints.length; i++) {
        if (waypoints[i] >= idx) break;
        prev = waypoints[i];
      }
      return prev;
    }

    function formatTime(sec) {
      if (sec == null) return '-';
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      const s = Math.round(sec % 60);
      return (h ? h + 'h ' : '') + m + 'm ' + s + 's';
    }

    function predictedTimeSeconds(dist, netRate) {
      if (!predictedData || !predictedData.length) return null;
      const slope = netRate;
      const range = ranges.find(r => slope >= r.min && slope < r.max);
      if (!range) return null;
      const grp = predictedData.find(g => g.label === range.label);
      if (!grp || grp.avg_pace == null) return null;
      return (dist / 1000) * grp.avg_pace * 60;
    }

    function predictedTime(dist, netRate) {
      const sec = predictedTimeSeconds(dist, netRate);
      return formatTime(sec);
    }

    function computePredictedTimes() {
      perKmData.forEach(row => {
        if (row.start_idx != null && row.end_idx != null) {
          const dist = points[row.end_idx][4] - points[row.start_idx][4];
          const avgUp = dist > 0 ? (row.gain / dist) * 100 : 0;
          const avgDown = dist > 0 ? (row.loss / dist) * 100 : 0;
          const net = avgUp - avgDown;
          row.actual_time_s = row.duration_s;
          row.pred_time_s = predictedTimeSeconds(dist, net);
        }
      });
      if (perKmTable) perKmTable.replaceData(perKmData);
      addTrendInfo(predictedData);
      if (predTable) predTable.replaceData(predictedData);
      updateSplitTimes();
    }

    function updateSplitTimes() {
      const rows = [];
      let cum = 0;
      perKmData.forEach((row, idx) => {
        if (row.pred_time_s != null) cum += row.pred_time_s;
        if ((idx + 1) % 5 === 0) {
          rows.push({ distance: `${idx + 1} km`, time: formatTime(cum) });
        }
      });
      rows.push({ distance: 'Finish', time: formatTime(cum) });
      if (!splitTimesTable) {
        splitTimesTable = new Tabulator('#splitTimesTable', {
          data: rows,
          layout: 'fitColumns',
          columns: [
            { title: 'Distance', field: 'distance', hozAlign: 'right' },
            { title: 'Predicted Time', field: 'time', hozAlign: 'right' }
          ]
        });
      } else {
        splitTimesTable.replaceData(rows);
      }
    }

    function computeStats(startIdx, endIdx) {
      if (endIdx <= startIdx) return null;
      const dist = points[endIdx][4] - points[startIdx][4];
      let gain = 0, loss = 0;
      for (let i = startIdx + 1; i <= endIdx; i++) {
        const diff = points[i][2] - points[i-1][2];
        if (diff > 0) gain += diff; else if (diff < 0) loss += -diff;
      }
      const avgUp = dist > 0 ? (gain / dist) * 100 : 0;
      const avgDown = dist > 0 ? (loss / dist) * 100 : 0;
      const netRate = avgUp - avgDown;
      const pred = predictedTime(dist, netRate);
      return { dist_m: dist, gain_m: gain, loss_m: loss, avg_up: avgUp, avg_down: avgDown, pred_time: pred };
    }

    function buildWaypointSegments() {
      const idxs = [0, ...waypoints, points.length - 1].sort((a, b) => a - b);
      const segments = [];
      for (let i = 0; i < idxs.length - 1; i++) {
        const stats = computeStats(idxs[i], idxs[i + 1]);
        if (stats) segments.push(Object.assign({ idx: i + 1 }, stats));
      }
      return segments;
    }

    function updateSegments() {
      const segs = buildWaypointSegments();

      const container = document.getElementById('waypointStats');
      container.innerHTML = '';

      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const headRow = document.createElement('tr');
      headRow.innerHTML = '<th class="label-cell">Name</th>';
      segs.forEach((seg, i) => {
        const startLabel = i === 0 ? 'Start' : `WP${i}`;
        const endLabel = i === segs.length - 1 ? 'Finish' : `WP${i+1}`;
        headRow.innerHTML += `<th>${startLabel}-${endLabel}</th>`;
      });
      thead.appendChild(headRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      const rows = [
        { label: 'Distance', format: seg => `${(seg.dist_m/1000).toFixed(1)} km` },
        { label: 'Elevation Gain', format: seg => `${seg.gain_m.toFixed(1)} m` },
        { label: 'Elevation Loss', format: seg => `${seg.loss_m.toFixed(1)} m` },
        { label: 'Average Up', format: seg => `${seg.avg_up.toFixed(2)} %` },
        { label: 'Average Down', format: seg => `${seg.avg_down.toFixed(2)} %` }
      ];

      rows.forEach(info => {
        const row = document.createElement('tr');
        row.innerHTML = `<td class="label-cell">${info.label}</td>` +
                        segs.map(seg => `<td>${info.format(seg)}</td>`).join('');
        tbody.appendChild(row);
      });

      table.appendChild(tbody);
      container.appendChild(table);
    }

    function updateWaypointDataset() {
      if (!chart) return;
      const data = profile.map((p, idx) => waypoints.includes(idx) ? p[1] : null);
      if (chart.data.datasets.length === 1) {
        chart.data.datasets.push({ label: 'Waypoints', data, borderColor: 'red', backgroundColor: 'red', showLine: false, pointRadius: 4 });
      } else {
        chart.data.datasets[1].data = data;
      }
      chart.update();
    }

    function addWaypoint(idx) {
      if (idx <= 0 || idx >= points.length - 1) return;
      if (!waypoints.includes(idx)) {
        waypoints.push(idx);
        waypoints.sort((a,b) => a-b);
        if (map) {
          const marker = new google.maps.Marker({ position: { lat: points[idx][0], lng: points[idx][1] }, map, label: String(waypoints.indexOf(idx)+1) });
          wpMarkers.push(marker);
        }
        updateSegments();
        updateWaypointDataset();
      }
    }

    document.getElementById('clearWaypointsBtn').addEventListener('click', () => {
      waypoints = [];
      wpMarkers.forEach(m => m.setMap(null));
      wpMarkers = [];
      updateSegments();
      updateWaypointDataset();
    });

  window.initMap = function() {
    createMap();
    initChart();
    initTable();
    updateSegments();
    updateWaypointDataset();
  };

  document.getElementById('downloadRateBtn').addEventListener('click', function() {
    const blob = new Blob([JSON.stringify(segmentData.summary, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'rate_groups.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  });

  document.getElementById('uploadRateBtn').addEventListener('click', function() {
    document.getElementById('rateFileInput').click();
  });

  document.getElementById('rateFileInput').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function() {
      try {
        const data = JSON.parse(reader.result);
        if (Array.isArray(data)) {
          predictedData.splice(0, predictedData.length, ...data);
          if (predTable) predTable.replaceData(predictedData);
          computePredictedTimes();
        }
      } catch(err) {
        alert('Invalid JSON');
      }
    };
    reader.readAsText(file);
    this.value = '';
  });

  document.getElementById('refreshRateBtn').addEventListener('click', function() {
    computePredictedTimes();
  });

</script>
<% if (googleMapsApiKey) { %>
<script async defer src="https://maps.googleapis.com/maps/api/js?key=<%= googleMapsApiKey %>&callback=initMap"></script>
<% } else { %>
<p style="color:red">Google Maps API key not set</p>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    initChart();
    initTable();
  });
</script>
<% } %>
  <% } else { %>
  <p>Please upload a GPX file using the drop zone above.</p>
  <% } %>

<script>
  // Upload form interactions should work even when no GPX data is displayed
  const dropZoneTop = document.getElementById('dropZoneTop');
  const fileInputTop = document.getElementById('fileInputTop');

  function submitGpxFile(file) {
    const formData = new FormData();
    formData.append('gpxfile', file);
    fetch('/upload', { method: 'POST', body: formData })
      .then(res => res.text())
      .then(html => {
        document.open();
        document.write(html);
        document.close();
      });
  }

  dropZoneTop.addEventListener('click', () => fileInputTop.click());
  dropZoneTop.addEventListener('dragover', e => {
    e.preventDefault();
    dropZoneTop.style.background = '#f0f0f0';
  });
  dropZoneTop.addEventListener('dragleave', () => {
    dropZoneTop.style.background = '';
  });
  dropZoneTop.addEventListener('drop', e => {
    e.preventDefault();
    dropZoneTop.style.background = '';
    const files = e.dataTransfer.files;
    if (files && files.length) {
      submitGpxFile(files[0]);
    }
  });
  fileInputTop.addEventListener('change', () => {
    if (fileInputTop.files.length) submitGpxFile(fileInputTop.files[0]);
  });

  // Prevent unintended navigation when dropping files outside the zone
  document.addEventListener('dragover', e => e.preventDefault());
  document.addEventListener('drop', e => {
    if (!dropZoneTop.contains(e.target)) {
      e.preventDefault();
    }
  });
</script>
</body>
</html>
