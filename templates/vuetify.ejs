<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>GPX Vuetify</title>
  <link href="https://cdn.jsdelivr.net/npm/vuetify@3.3.6/dist/vuetify.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/@mdi/font@7.x/css/materialdesignicons.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Material+Icons" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet">
  <script src="https://unpkg.com/vue@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/vuetify@3.3.6/dist/vuetify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vuetify@3.3.6/dist/vuetify-labs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
  <style>
    #map { height: 400px; }
    #chart { height: 300px; }
    .up1 { color: #6bc56b; }
    .up2 { color: #2e8b57; }
    .up3 { color: #006400; }
    .up4 { color: #004b00; }
    .up5 { color: #002b00; }
    .down1 { color: #e9967a; }
    .down2 { color: #cd5c5c; }
    .down3 { color: #8b0000; }
    .down4 { color: #7a0000; }
    .down5 { color: #3f0000; }
    .flat { color: #808080; }
    .material-symbols-outlined {
      font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
    }
    .group-table .v-data-table-footer__items-per-page,
    .group-table .v-data-table-footer__info,
    .estimated-table .v-data-table-footer__items-per-page,
    .estimated-table .v-data-table-footer__info,
    .perkm-table .v-data-table-footer__items-per-page,
    .perkm-table .v-data-table-footer__info,
    .split-table .v-data-table-footer__items-per-page,
    .split-table .v-data-table-footer__info {
      display: none;
    }
    .group-table .v-data-table-footer,
    .estimated-table .v-data-table-footer {
      display: none;
    }
    .v-data-table {
      border: 2px solid #e0e0e0;
      border-radius: 24px;
      overflow: hidden;
    }
    .v-data-table thead th {
      background: #f5f5fa;
      border-right: 1px solid #e0e0e0;
    }
    .v-data-table thead th:last-child {
      border-right: none;
    }
    .v-data-table tbody td {
      border-right: 1px solid #e0e0e0;
    }
    .v-data-table tbody td:last-child {
      border-right: none;
    }
    .editable-input {
      background-color: #fffbe6;
      max-width: 140px;
    }
  </style>
  <%- include('_favicon.ejs') %>
</head>
<body>
<div id="app">
  <v-app>
    <v-app-bar app color="primary" dark>
      <v-toolbar-title>
        <img src="/favicon.ico" alt="favicon" style="width:24px;height:24px;vertical-align:middle;margin-right:8px;">
        トレイルランナー向けGPX分析ツール
      </v-toolbar-title>
    </v-app-bar>
    <v-main>
      <v-container class="mt-4">
        <v-expansion-panels v-model="uploaderPanel">
          <v-expansion-panel>
            <v-expansion-panel-title expand-icon="mdi-chevron-down">Upload GPX</v-expansion-panel-title>
            <v-expansion-panel-text>
              <v-file-input label="GPX File" accept=".gpx" v-model="file"></v-file-input>
              <v-btn color="primary" class="mt-2" @click="submit">Upload</v-btn>
            </v-expansion-panel-text>
          </v-expansion-panel>
        </v-expansion-panels>

        <div v-if="!stats.trackpoints || !stats.trackpoints.length" class="mt-6">
          <v-alert type="info" border="start" color="primary" variant="tonal">
            GPXファイルをアップロードしてください。
          </v-alert>
        </div>
        <div v-if="stats.trackpoints && stats.trackpoints.length" class="mt-6">
          <v-row>
            <v-col cols="12" sm="6" v-for="(value, key) in summaryStats" :key="key">
              <v-card>
                <v-card-title>{{ key }}</v-card-title>
                <v-card-text>{{ value }}</v-card-text>
              </v-card>
            </v-col>
          </v-row>

          <v-tabs v-model="tab" class="mt-4 elevation-1" bg-color="grey-lighten-4" color="primary">
            <v-tab :value="0">統計情報・予測</v-tab>
            <v-tab :value="1">地図・高低差</v-tab>
          </v-tabs>
          <v-window v-model="tab">
            <v-window-item :value="0" class="mt-4">
              <h2>キロ区間分析</h2>
              <v-data-table :items="perKmData" :headers="perKmHeaders" class="mb-4 perkm-table" density="compact">
                <template v-slot:item.trend="{ item }">
                  <span v-html="item.raw.trend"></span>
                </template>
              </v-data-table>
              <h2 class="mt-4">勾配グループ分析</h2>
              <v-data-table :items="summaryGroups" :headers="rateHeaders" class="mb-4 group-table" density="compact" hide-default-footer items-per-page="13">
                <template v-slot:item.trend="{ item }">
                  <span v-html="item.raw.trend"></span>
                </template>
                <template v-slot:item.avg_net_rate="{ item }">
                  {{ item.raw.avg_net_rate == null ? '-' : Number(item.raw.avg_net_rate).toFixed(2) }}
                </template>
                <template v-slot:item.avg_pace="{ item }">
                  {{ item.raw.avg_pace == null ? '-' : Number(item.raw.avg_pace).toFixed(2) }}
                </template>
              </v-data-table>
              <h2 class="mt-4">想定ペース</h2>
              <v-data-table :items="predictedData" :headers="rateHeaders" class="mb-2 estimated-table" density="compact" hide-default-footer items-per-page="13">
                <template v-slot:item.trend="{ item }">
                  <span v-html="item.raw.trend"></span>
                </template>
                <template v-slot:item.avg_net_rate="{ item }">
                  {{ item.raw.avg_net_rate == null ? '-' : Number(item.raw.avg_net_rate).toFixed(2) }}
                </template>
                <template v-slot:item.avg_pace="{ item }">
                  <v-text-field v-model.number="item.raw.avg_pace" type="number" density="compact" hide-details class="editable-input" @change="computePredictedTimes"></v-text-field>
                </template>
              </v-data-table>
              <div class="d-flex mb-4">
                <v-btn class="mr-2" color="primary" @click="downloadPredicted">JSONダウンロード</v-btn>
                <v-btn color="primary" @click="computePredictedTimes">再計算</v-btn>
              </div>
              <h2 class="mt-4">区間想定時間</h2>
              <v-data-table :items="splitTimes" :headers="splitHeaders" density="compact" class="split-table"></v-data-table>
            </v-window-item>
            <v-window-item :value="1" class="mt-4">
              <div id="map" class="mb-4"></div>
              <canvas id="chart"></canvas>
            </v-window-item>
          </v-window>
        </div>
      </v-container>
    </v-main>
  </v-app>
</div>
<script>
const { createApp } = Vue;
const vuetify = Vuetify.createVuetify({
  components: window.VuetifyLabs
    ? { ...Vuetify.components, ...VuetifyLabs.components }
    : Vuetify.components,
  directives: Vuetify.directives
});
createApp({
  data() {
    return {
      file: null,
      stats: {},
      segmentSummary: null,
      predictedData: [],
      splitTimes: [],
      ranges: [
        { label: '[-50% -    ]', min: -Infinity, max: -50 },
        { label: '[-40% - -50%]', min: -50, max: -40 },
        { label: '[-30% - -40%]', min: -40, max: -30 },
        { label: '[-20% - -30%]', min: -30, max: -20 },
        { label: '[-10% - -20%]', min: -20, max: -10 },
        { label: '[ -5% - -10%]', min: -10, max: -5 },
        { label: '[-5%  -   5%]', min: -5, max: 5 },
        { label: '[5%  -  10%]', min: 5, max: 10 },
        { label: '[10% -  20%]', min: 10, max: 20 },
        { label: '[20% -  30%]', min: 20, max: 30 },
        { label: '[30% -  40%]', min: 30, max: 40 },
        { label: '[40% -  50%]', min: 40, max: 50 },
        { label: '[50% -    ]', min: 50, max: Infinity }
      ],
      uploaderPanel: 0,
      tab: 0
    };
  },
  computed: {
    summaryStats() {
      if (!this.stats.trackpoints) return {};
      return {
        'トラックポイント数': this.stats.trackpoints.length,
        '総距離（km）': (this.stats.distance_m/1000).toFixed(2) + ' km',
        '最高標高': this.stats.highest_elevation_m.toFixed(1) + ' m',
        '最低標高': this.stats.lowest_elevation_m.toFixed(1) + ' m',
        '総獲得標高': this.stats.total_gain_m.toFixed(1) + ' m',
        '総標高損失': this.stats.total_loss_m.toFixed(1) + ' m'
      };
    },
    perKmData() { return this.stats.per_km_elevation || []; },
    rateGroups() { return this.segmentSummary ? this.segmentSummary.segments : []; },
    summaryGroups() { return this.segmentSummary ? this.segmentSummary.summary : []; },
    perKmHeaders() {
      return [
        { title: 'キロ', key: 'km' },
        { title: '上昇 (m)', key: 'gain' },
        { title: '降下 (m)', key: 'loss' },
        { title: '所要時間', key: 'actual_time' },
        { title: '予想時間', key: 'pred_time' },
        { title: '', key: 'trend', sortable: false }
      ];
    },
    rateHeaders() {
      return [
        { title: '', key: 'trend', sortable: false },
        { title: '勾配グループ', key: 'label' },
        { title: '平均上昇降下率(%)', key: 'avg_net_rate' },
        { title: '平均ペース (min/km)', key: 'avg_pace' }
      ];
    },
    segmentHeaders() {
      return [
        { title: 'キロ', key: 'km' },
        { title: '上昇降下率 (%)', key: 'net_rate' },
        { title: 'ペース (min/km)', key: 'pace_min_per_km' }
      ];
    },
    splitHeaders() {
      return [
        { title: '距離 (km)', key: 'distance' },
        { title: '予想時間', key: 'time' }
      ];
    }
  },
  watch: {
    tab(val) {
      if (val === 1) {
        this.$nextTick(() => {
          this.initMap();
          this.initChart();
        });
      }
    },
    predictedData: {
      handler() { this.computePredictedTimes(); },
      deep: true
    }
  },
  methods: {
    submit() {
      const file = Array.isArray(this.file) ? this.file[0] : this.file;
      if (!file) return;
      const formData = new FormData();
      formData.append('gpxfile', file);
      fetch('/api/upload', { method: 'POST', body: formData })
        .then(res => res.json())
        .then(data => {
          this.stats = data.stats;
          this.segmentSummary = data.segmentSummary;
          if (this.segmentSummary && this.segmentSummary.summary) {
            this.segmentSummary.summary.forEach(r => {
              r.avg_net_rate = r.avg_net_rate == null ? null : Number(r.avg_net_rate);
              r.avg_pace = r.avg_pace == null ? null : Number(r.avg_pace);
            });
          }
          if (this.segmentSummary && this.segmentSummary.segments) {
            this.segmentSummary.segments.forEach(s => {
              s.net_rate = s.net_rate == null ? null : Number(s.net_rate);
              s.pace_min_per_km = s.pace_min_per_km == null ? null : Number(s.pace_min_per_km);
            });
          }
          this.predictedData = JSON.parse(JSON.stringify(this.segmentSummary?.summary || []));
          this.predictedData.forEach(r => {
            r.avg_net_rate = r.avg_net_rate == null ? null : Number(r.avg_net_rate);
            r.avg_pace = r.avg_pace == null ? null : Number(r.avg_pace);
          });
          this.addTrendInfo(this.stats.per_km_elevation);
          if (this.segmentSummary && this.segmentSummary.summary) this.addTrendInfo(this.segmentSummary.summary);
          this.addTrendInfo(this.predictedData);
          this.computePredictedTimes();
          this.$nextTick(() => { this.initMap(); this.initChart(); });
          this.uploaderPanel = null;
        })
        .catch(() => alert('Failed to parse GPX'));
    },
    downloadPredicted() {
      const blob = new Blob([JSON.stringify(this.predictedData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'rate_groups.json';
      a.click();
      URL.revokeObjectURL(url);
    },
    initMap() {
      if (!this.stats.trackpoints || !this.stats.trackpoints.length || !window.google) return;
      const path = this.stats.trackpoints.map(p => ({ lat: p[0], lng: p[1] }));
      const map = new google.maps.Map(document.getElementById('map'), {
        zoom: 14,
        center: path[0],
        mapTypeId: 'terrain'
      });
      new google.maps.Polyline({ path, map, strokeColor: 'blue' });
      if (this.stats.waypoints) {
        this.stats.waypoints.forEach(wp => {
          new google.maps.Marker({ position: { lat: wp.lat, lng: wp.lon }, map, title: wp.name || '' });
        });
      }
    },
    initChart() {
      if (!this.stats.profile || !this.stats.profile.length || !window.Chart) return;
      const ctx = document.getElementById('chart').getContext('2d');
      const labels = this.stats.profile.map(p => (p[0] / 1000).toFixed(1));
      const elev = this.stats.profile.map(p => p[1]);
      new Chart(ctx, {
        type: 'line',
        data: { labels, datasets: [{ label: 'Elevation', data: elev, borderColor: 'blue', fill: false, pointRadius: 0 }] },
        options: { responsive: true, scales: { x: { title: { display: true, text: 'Distance (km)' } }, y: { title: { display: true, text: 'Elevation (m)' } } } }
      });
    },
    formatTime(sec) {
      if (sec == null) return '-';
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      const s = Math.round(sec % 60);
      return (h ? h + 'h ' : '') + m + 'm ' + s + 's';
    },
    predictedTimeSeconds(dist, netRate) {
      if (!this.predictedData || !this.predictedData.length) return null;
      const slope = netRate;
      const range = this.ranges.find(r => slope >= r.min && slope < r.max);
      if (!range) return null;
      const grp = this.predictedData.find(g => g.label === range.label);
      if (!grp || grp.avg_pace == null) return null;
      return (dist / 1000) * grp.avg_pace * 60;
    },
    addTrendInfo(arr) {
      if (!arr) return;
      arr.forEach(row => {
        const diff = (row.gain != null && row.loss != null) ? (row.gain - row.loss) : row.avg_net_rate;
        let icon, cls;
        if (diff > 10) {
          icon = 'trending_up';
          if (diff > 50) cls = 'up5';
          else if (diff > 40) cls = 'up4';
          else if (diff > 30) cls = 'up3';
          else if (diff > 20) cls = 'up2';
          else cls = 'up1';
        } else if (diff < -10) {
          icon = 'trending_down';
          if (diff < -50) cls = 'down5';
          else if (diff < -40) cls = 'down4';
          else if (diff < -30) cls = 'down3';
          else if (diff < -20) cls = 'down2';
          else cls = 'down1';
        } else {
          icon = 'trending_flat';
          cls = 'flat';
        }
        row.trend = `<span class="${cls} material-symbols-outlined">${icon}</span>`;
      });
    },
    computePredictedTimes() {
      if (!this.stats.trackpoints) return;
      const pts = this.stats.trackpoints;
      (this.stats.per_km_elevation || []).forEach(row => {
        if (row.start_idx != null && row.end_idx != null) {
          const dist = pts[row.end_idx][4] - pts[row.start_idx][4];
          const avgUp = dist > 0 ? (row.gain / dist) * 100 : 0;
          const avgDown = dist > 0 ? (row.loss / dist) * 100 : 0;
          const net = avgUp - avgDown;
          row.actual_time_s = row.duration_s;
          row.pred_time_s = this.predictedTimeSeconds(dist, net);
          row.actual_time = this.formatTime(row.actual_time_s);
          row.pred_time = this.formatTime(row.pred_time_s);
        }
      });
      this.splitTimes = [];
      let cum = 0;
      (this.stats.per_km_elevation || []).forEach((row, idx) => {
        if (row.pred_time_s != null) cum += row.pred_time_s;
        if ((idx + 1) % 5 === 0) {
          this.splitTimes.push({ distance: `${idx + 1} km`, time: this.formatTime(cum) });
        }
      });
      this.splitTimes.push({ distance: 'Finish', time: this.formatTime(cum) });
    }
  }
}).use(vuetify).mount('#app');
</script>
<% if (googleMapsApiKey) { %>
<script async defer src="https://maps.googleapis.com/maps/api/js?key=<%= googleMapsApiKey %>"></script>
<% } %>
</body>
</html>
