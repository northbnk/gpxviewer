<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>GPX Vuetify</title>
  <link href="https://cdn.jsdelivr.net/npm/vuetify@3.3.6/dist/vuetify.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/@mdi/font@7.x/css/materialdesignicons.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Material+Icons" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet">
  <script src="https://unpkg.com/vue@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/vuetify@3.3.6/dist/vuetify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vuetify@3.3.6/dist/vuetify-labs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    #map { height: 400px; }
    #chart { height: 150px; max-height: 400px; }
    .up1 { color: #6bc56b; }
    .up2 { color: #2e8b57; }
    .up3 { color: #006400; }
    .up4 { color: #004b00; }
    .up5 { color: #002b00; }
    .down1 { color: #e9967a; }
    .down2 { color: #cd5c5c; }
    .down3 { color: #8b0000; }
    .down4 { color: #7a0000; }
    .down5 { color: #3f0000; }
    .flat { color: #808080; }
    .material-symbols-outlined {
      font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
    }
    .group-table .v-data-table-footer__items-per-page,
    .group-table .v-data-table-footer__info,
    .estimated-table .v-data-table-footer__items-per-page,
    .estimated-table .v-data-table-footer__info,
    .perkm-table .v-data-table-footer__items-per-page,
    .perkm-table .v-data-table-footer__info,
    .split-table .v-data-table-footer__items-per-page,
    .split-table .v-data-table-footer__info {
      display: none;
    }
    .group-table .v-data-table-footer,
    .estimated-table .v-data-table-footer {
      display: none;
    }
    .v-data-table {
      border: 2px solid #e0e0e0;
      border-radius: 24px;
      overflow: hidden;
    }
    .v-data-table thead th {
      background: #f5f5fa;
      border-right: 1px solid #e0e0e0;
    }
    .v-data-table thead th:last-child {
      border-right: none;
    }
    .v-data-table tbody td {
      border-right: 1px solid #e0e0e0;
    }
    .v-data-table tbody td:last-child {
      border-right: none;
    }
    .editable-input {
      background-color: #fffbe6;
      max-width: 140px;
    }
    #waypointStats { overflow-x:auto; }
    #waypointStats table { width:100%; table-layout:fixed; border-collapse:collapse; }
    #waypointStats th { padding:2px 4px; text-align:right; }
    #waypointStats th.label-cell { text-align:left; font-weight:bold; width:120px; min-width:80px; }
    #waypointStats td { padding:2px 4px; text-align:right; }
    #waypointStats td.label-cell { text-align:left; font-weight:bold; }
    #waypointStats th:not(.label-cell), #waypointStats td:not(.label-cell) { text-align:center; }
    #waypointStats th:not(.label-cell), #waypointStats td:not(.label-cell) { width:auto; }
  </style>
  <%- include('_favicon.ejs') %>
</head>
<body>
<div id="app">
  <v-app>
    <v-app-bar app color="primary" dark>
      <v-toolbar-title>
        <img src="/favicon.ico" alt="favicon" style="width:24px;height:24px;vertical-align:middle;margin-right:8px;">
        トレイルランナー向けGPX分析ツール
      </v-toolbar-title>
    </v-app-bar>
    <v-main>
      <v-container class="mt-4">
        <v-expansion-panels v-model="uploaderPanel">
          <v-expansion-panel>
            <v-expansion-panel-title expand-icon="mdi-chevron-down">GPXファイルアップロード</v-expansion-panel-title>
            <v-expansion-panel-text>
              <v-file-input label="GPX File" accept=".gpx" v-model="file"></v-file-input>
              <v-btn color="primary" class="mt-2" @click="submit">アップロード</v-btn>
            </v-expansion-panel-text>
          </v-expansion-panel>
        </v-expansion-panels>

        <div v-if="!stats.trackpoints || !stats.trackpoints.length" class="mt-6">
          <v-alert type="info" border="start" color="primary" variant="tonal">
            GPXファイルをアップロードしてください。
          </v-alert>
        </div>
        <div v-if="stats.trackpoints && stats.trackpoints.length" class="mt-6">
          <v-row>
            <v-col cols="12" sm="6" v-for="(value, key) in summaryStats" :key="key">
              <v-card>
                <v-card-title>{{ key }}</v-card-title>
                <v-card-text>{{ value }}</v-card-text>
              </v-card>
            </v-col>
          </v-row>

          <v-tabs v-model="tab" class="mt-4 elevation-1" bg-color="grey-lighten-4" color="primary">
            <v-tab :value="0">統計情報・予測</v-tab>
            <v-tab :value="1">地図・高低差</v-tab>
            <v-tab :value="2">AI分析</v-tab>
          </v-tabs>
          <v-window v-model="tab">
            <v-window-item :value="0" class="mt-4">
              <h2>キロ区間分析</h2>
              <v-data-table :items="perKmData" :headers="perKmHeaders" class="mb-4 perkm-table" density="compact" @click:row="onKmRowClick">
                <template v-slot:item.trend="{ item }">
                  <span v-html="item.raw.trend"></span>
                </template>
              </v-data-table>
              <h2 class="mt-4">勾配グループ分析</h2>
              <v-data-table :items="summaryGroups" :headers="rateHeaders" class="mb-4 group-table" density="compact" hide-default-footer items-per-page="13">
                <template v-slot:item.trend="{ item }">
                  <span v-html="item.raw.trend"></span>
                </template>
                <template v-slot:item.avg_net_rate="{ item }">
                  {{ item.raw.avg_net_rate == null ? '-' : Number(item.raw.avg_net_rate).toFixed(2) }}
                </template>
                <template v-slot:item.avg_pace="{ item }">
                  {{ item.raw.avg_pace == null ? '-' : Number(item.raw.avg_pace).toFixed(2) }}
                </template>
              </v-data-table>
              <div class="d-flex mb-4">
                <v-btn color="primary" @click="downloadGroups">自身のペース分析ファイルをダウンロード</v-btn>
              </div>
              <h2 class="mt-4">想定ペース</h2>
              <v-data-table :items="predictedData" :headers="rateHeaders" class="mb-2 estimated-table" density="compact" hide-default-footer items-per-page="13">
                <template v-slot:item.trend="{ item }">
                  <span v-html="item.raw.trend"></span>
                </template>
                <template v-slot:item.avg_net_rate="{ item }">
                  {{ item.raw.avg_net_rate == null ? '-' : Number(item.raw.avg_net_rate).toFixed(2) }}
                </template>
                <template v-slot:item.avg_pace="{ item }">
                  <v-text-field v-model.number="item.raw.avg_pace" type="number" density="compact" hide-details class="editable-input" @change="computePredictedTimes"></v-text-field>
                </template>
              </v-data-table>
              <div class="d-flex mb-4">
                <v-btn class="mr-2" color="primary" @click="downloadPredicted">自身のペース分析ファイルをダウンロード</v-btn>
                <v-btn color="primary" @click="computePredictedTimes">再計算</v-btn>
              </div>
              <h2 class="mt-4">区間想定時間</h2>
              <v-data-table :items="splitTimes" :headers="splitHeaders" density="compact" class="split-table"></v-data-table>
            </v-window-item>
            <v-window-item :value="1" class="mt-4">
              <div id="map" class="mb-4"></div>
              <canvas id="chart"></canvas>
              <div class="mt-4">
                <v-btn size="small" class="mb-2" @click="clearWaypoints">クリア</v-btn>
                <div id="waypointStats"></div>
              </div>
            </v-window-item>
            <v-window-item :value="2" class="mt-4">
              <div>
                <v-btn color="primary" @click="generateAnalysis">Generate Text Report</v-btn>
                <div class="mt-4" v-html="analysisText"></div>
              </div>
            </v-window-item>
          </v-window>
        </div>
      </v-container>
    </v-main>
  </v-app>
</div>
<script>
const { createApp } = Vue;
let hoverLine = {
  id: 'hoverLine',
  afterDraw(chart) {
    if (chart.tooltip && chart.tooltip._active && chart.tooltip._active.length) {
      const ctx = chart.ctx;
      const x = chart.tooltip._active[0].element.x;
      const topY = chart.scales.y.top;
      const bottomY = chart.scales.y.bottom;
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(x, topY);
      ctx.lineTo(x, bottomY);
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(0,0,0,0.4)';
      ctx.stroke();
      ctx.restore();
    }
  }
};
let rangeHighlight = {
  id: 'rangeHighlight',
  beforeDatasetsDraw(chart) {
    if (!chart._selectedRange) return;
    const { startIdx, endIdx } = chart._selectedRange;
    const meta = chart.getDatasetMeta(0);
    const ctx = chart.ctx;
    const startX = meta.data[startIdx].x;
    const endX = meta.data[endIdx].x;
    ctx.save();
    ctx.fillStyle = 'rgba(255,0,0,0.1)';
    ctx.fillRect(startX, chart.scales.y.top, endX - startX, chart.scales.y.bottom - chart.scales.y.top);
    ctx.restore();
  }
};
const vuetify = Vuetify.createVuetify({
  components: window.VuetifyLabs
    ? { ...Vuetify.components, ...VuetifyLabs.components }
    : Vuetify.components,
  directives: Vuetify.directives
});
createApp({
  data() {
    return {
      file: null,
      stats: {},
      segmentSummary: null,
      predictedData: [],
      splitTimes: [],
      map: null,
      chart: null,
      marker: null,
      rangePolyline: null,
      waypoints: [],
      wpMarkers: [],
      ranges: [
        { label: '[-50% -    ]', min: -Infinity, max: -50 },
        { label: '[-40% - -50%]', min: -50, max: -40 },
        { label: '[-30% - -40%]', min: -40, max: -30 },
        { label: '[-20% - -30%]', min: -30, max: -20 },
        { label: '[-10% - -20%]', min: -20, max: -10 },
        { label: '[ -5% - -10%]', min: -10, max: -5 },
        { label: '[-5%  -   5%]', min: -5, max: 5 },
        { label: '[5%  -  10%]', min: 5, max: 10 },
        { label: '[10% -  20%]', min: 10, max: 20 },
        { label: '[20% -  30%]', min: 20, max: 30 },
        { label: '[30% -  40%]', min: 30, max: 40 },
        { label: '[40% -  50%]', min: 40, max: 50 },
        { label: '[50% -    ]', min: 50, max: Infinity }
      ],
      uploaderPanel: 0,
      tab: 0,
      analysisText: ''
    };
  },
  computed: {
    summaryStats() {
      if (!this.stats.trackpoints) return {};
      return {
        'トラックポイント数': this.stats.trackpoints.length,
        '総距離（km）': (this.stats.distance_m/1000).toFixed(2) + ' km',
        '最高標高': this.stats.highest_elevation_m.toFixed(1) + ' m',
        '最低標高': this.stats.lowest_elevation_m.toFixed(1) + ' m',
        '総獲得標高': this.stats.total_gain_m.toFixed(1) + ' m',
        '総標高損失': this.stats.total_loss_m.toFixed(1) + ' m'
      };
    },
    perKmData() { return this.stats.per_km_elevation || []; },
    rateGroups() { return this.segmentSummary ? this.segmentSummary.segments : []; },
    summaryGroups() { return this.segmentSummary ? this.segmentSummary.summary : []; },
    perKmHeaders() {
      return [
        { title: 'キロ', key: 'km' },
        { title: '上昇 (m)', key: 'gain' },
        { title: '降下 (m)', key: 'loss' },
        { title: '所要時間', key: 'actual_time' },
        { title: '予想時間', key: 'pred_time' },
        { title: '', key: 'trend', sortable: false }
      ];
    },
    rateHeaders() {
      return [
        { title: '', key: 'trend', sortable: false },
        { title: '勾配グループ', key: 'label' },
        { title: '平均上昇降下率(%)', key: 'avg_net_rate' },
        { title: '平均ペース (min/km)', key: 'avg_pace' }
      ];
    },
    segmentHeaders() {
      return [
        { title: 'キロ', key: 'km' },
        { title: '上昇降下率 (%)', key: 'net_rate' },
        { title: 'ペース (min/km)', key: 'pace_min_per_km' }
      ];
    },
    splitHeaders() {
      return [
        { title: '距離 (km)', key: 'distance' },
        { title: '予想時間', key: 'time' }
      ];
    }
  },
  watch: {
    tab(val) {
      if (val === 1) {
        this.$nextTick(() => {
          this.initMap();
          this.initChart();
          this.loadPredefinedWaypoints();
          this.updateSegments();
          this.updateWaypointDataset();
        });
      }
    },
    predictedData: {
      handler() { this.computePredictedTimes(); },
      deep: true
    }
  },
  methods: {
    submit() {
      const file = Array.isArray(this.file) ? this.file[0] : this.file;
      if (!file) return;
      const formData = new FormData();
      formData.append('gpxfile', file);
      fetch('/api/upload', { method: 'POST', body: formData })
        .then(res => res.json())
        .then(data => {
          this.stats = data.stats;
          this.segmentSummary = data.segmentSummary;
          if (this.segmentSummary && this.segmentSummary.summary) {
            this.segmentSummary.summary.forEach(r => {
              r.avg_net_rate = r.avg_net_rate == null ? null : Number(r.avg_net_rate);
              r.avg_pace = r.avg_pace == null ? null : Number(r.avg_pace);
            });
          }
          if (this.segmentSummary && this.segmentSummary.segments) {
            this.segmentSummary.segments.forEach(s => {
              s.net_rate = s.net_rate == null ? null : Number(s.net_rate);
              s.pace_min_per_km = s.pace_min_per_km == null ? null : Number(s.pace_min_per_km);
            });
          }
          this.predictedData = JSON.parse(JSON.stringify(this.segmentSummary?.summary || []));
          this.predictedData.forEach(r => {
            r.avg_net_rate = r.avg_net_rate == null ? null : Number(r.avg_net_rate);
            r.avg_pace = r.avg_pace == null ? null : Number(r.avg_pace);
          });
          this.addTrendInfo(this.stats.per_km_elevation);
          if (this.segmentSummary && this.segmentSummary.summary) this.addTrendInfo(this.segmentSummary.summary);
          this.addTrendInfo(this.predictedData);
          this.computePredictedTimes();
          this.waypoints = [];
          this.wpMarkers.forEach(m => m.setMap(null));
          this.wpMarkers = [];
          this.$nextTick(() => {
            this.initMap();
            this.initChart();
            this.loadPredefinedWaypoints();
            this.updateSegments();
            this.updateWaypointDataset();
          });
          this.uploaderPanel = null;
        })
        .catch(() => alert('Failed to parse GPX'));
    },
    downloadPredicted() {
      const blob = new Blob([JSON.stringify(this.predictedData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'rate_groups.json';
      a.click();
      URL.revokeObjectURL(url);
    },
    downloadGroups() {
      const blob = new Blob([JSON.stringify(this.summaryGroups, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'rate_groups.json';
      a.click();
      URL.revokeObjectURL(url);
    },
    initMap() {
      if (!this.stats.trackpoints || !this.stats.trackpoints.length || !window.google) return;
      const path = this.stats.trackpoints.map(p => ({ lat: p[0], lng: p[1] }));
      this.map = new google.maps.Map(document.getElementById('map'), {
        zoom: 14,
        center: path[0],
        zoomControl: true,
        scrollwheel: true,
        gestureHandling: 'greedy',
        mapTypeId: 'terrain'
      });
      const bounds = new google.maps.LatLngBounds();
      path.forEach(p => bounds.extend(p));
      this.map.fitBounds(bounds);
      const poly = new google.maps.Polyline({ path, map: this.map, strokeColor: 'blue' });
      this.marker = new google.maps.Marker({ map: this.map });
      this.map.addListener('mousemove', e => {
        const idx = this.nearestIndex(e.latLng.lat(), e.latLng.lng());
        this.updateHighlight(idx);
      });
      poly.addListener('mousemove', e => {
        const idx = this.nearestIndex(e.latLng.lat(), e.latLng.lng());
        this.updateHighlight(idx);
      });
      this.map.addListener('click', e => {
        const idx = this.nearestIndex(e.latLng.lat(), e.latLng.lng());
        this.addWaypoint(idx);
      });
      poly.addListener('click', e => {
        const idx = this.nearestIndex(e.latLng.lat(), e.latLng.lng());
        this.addWaypoint(idx);
      });
      if (this.stats.waypoints) {
        this.stats.waypoints.forEach(wp => {
          new google.maps.Marker({ position: { lat: wp.lat, lng: wp.lon }, map: this.map, title: wp.name || '' });
        });
      }
    },
    initChart() {
      if (!this.stats.profile || !this.stats.profile.length || !window.Chart) return;
      const ctx = document.getElementById('chart').getContext('2d');
      const labels = this.stats.profile.map(p => (p[0] / 1000).toFixed(1));
      const elev = this.stats.profile.map(p => p[1]);
      Chart.register(hoverLine);
      Chart.register(rangeHighlight);
      this.chart = new Chart(ctx, {
        type: 'line',
        data: { labels, datasets: [{ label: 'Elevation', data: elev, borderColor: 'blue', fill: false, pointRadius: 0 }] },
        options: {
          responsive: true,
          interaction: { mode: 'nearest', intersect: false },
          scales: { x: { title: { display: true, text: 'Distance (km)' } }, y: { title: { display: true, text: 'Elevation (m)' } } }
        },
        plugins: [hoverLine, rangeHighlight]
      });
      document.getElementById('chart').addEventListener('mousemove', evt => {
        const els = this.chart.getElementsAtEventForMode(evt, 'nearest', { intersect: false }, false);
        if (els.length) this.updateHighlight(els[0].index);
      });
      document.getElementById('chart').addEventListener('click', evt => {
        const els = this.chart.getElementsAtEventForMode(evt, 'nearest', { intersect: false }, false);
        if (els.length) this.addWaypoint(els[0].index);
      });
    },
    formatTime(sec) {
      if (sec == null) return '-';
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      const s = Math.round(sec % 60);
      return (h ? h + 'h ' : '') + m + 'm ' + s + 's';
    },
    predictedTimeSeconds(dist, netRate) {
      if (!this.predictedData || !this.predictedData.length) return null;
      const slope = netRate;
      const range = this.ranges.find(r => slope >= r.min && slope < r.max);
      if (!range) return null;
      const grp = this.predictedData.find(g => g.label === range.label);
      if (!grp || grp.avg_pace == null) return null;
      return (dist / 1000) * grp.avg_pace * 60;
    },
    addTrendInfo(arr) {
      if (!arr) return;
      arr.forEach(row => {
        const diff = (row.gain != null && row.loss != null) ? (row.gain - row.loss) : row.avg_net_rate;
        let icon, cls;
        if (diff > 10) {
          icon = 'trending_up';
          if (diff > 50) cls = 'up5';
          else if (diff > 40) cls = 'up4';
          else if (diff > 30) cls = 'up3';
          else if (diff > 20) cls = 'up2';
          else cls = 'up1';
        } else if (diff < -10) {
          icon = 'trending_down';
          if (diff < -50) cls = 'down5';
          else if (diff < -40) cls = 'down4';
          else if (diff < -30) cls = 'down3';
          else if (diff < -20) cls = 'down2';
          else cls = 'down1';
        } else {
          icon = 'trending_flat';
          cls = 'flat';
        }
        row.trend = `<span class="${cls} material-symbols-outlined">${icon}</span>`;
      });
    },
    computePredictedTimes() {
      if (!this.stats.trackpoints) return;
      const pts = this.stats.trackpoints;
      (this.stats.per_km_elevation || []).forEach(row => {
        if (row.start_idx != null && row.end_idx != null) {
          const dist = pts[row.end_idx][4] - pts[row.start_idx][4];
          const avgUp = dist > 0 ? (row.gain / dist) * 100 : 0;
          const avgDown = dist > 0 ? (row.loss / dist) * 100 : 0;
          const net = avgUp - avgDown;
          row.actual_time_s = row.duration_s;
          row.pred_time_s = this.predictedTimeSeconds(dist, net);
          row.actual_time = this.formatTime(row.actual_time_s);
          row.pred_time = this.formatTime(row.pred_time_s);
        }
      });
      this.splitTimes = [];
      let cum = 0;
      (this.stats.per_km_elevation || []).forEach((row, idx) => {
        if (row.pred_time_s != null) cum += row.pred_time_s;
        if ((idx + 1) % 5 === 0) {
          this.splitTimes.push({ distance: `${idx + 1} km`, time: this.formatTime(cum) });
        }
      });
      this.splitTimes.push({ distance: 'Finish', time: this.formatTime(cum) });
    },
    nearestIndex(lat, lng) {
      let best = 0;
      let bestDist = Infinity;
      const pts = this.stats.trackpoints || [];
      for (let i = 0; i < pts.length; i++) {
        const dLat = pts[i][0] - lat;
        const dLng = pts[i][1] - lng;
        const d = dLat * dLat + dLng * dLng;
        if (d < bestDist) { bestDist = d; best = i; }
      }
      return best;
    },
    updateHighlight(idx) {
      if (!this.stats.trackpoints || !this.stats.trackpoints[idx]) return;
      if (this.marker) {
        this.marker.setPosition({ lat: this.stats.trackpoints[idx][0], lng: this.stats.trackpoints[idx][1] });
      }
      if (this.chart) {
        this.chart.setActiveElements([{ datasetIndex: 0, index: idx }]);
        this.chart.tooltip.setActiveElements([{ datasetIndex: 0, index: idx }]);
        this.chart.update();
      }
    },
    highlightRange(startIdx, endIdx) {
      if (!this.chart) return;
      this.chart._selectedRange = { startIdx, endIdx };
      this.chart.update();
      if (this.map) {
        const path = [];
        for (let i = startIdx; i <= endIdx; i++) {
          path.push({ lat: this.stats.trackpoints[i][0], lng: this.stats.trackpoints[i][1] });
        }
        if (!this.rangePolyline) {
          this.rangePolyline = new google.maps.Polyline({
            path,
            map: this.map,
            strokeColor: 'red',
            strokeOpacity: 0.8,
            strokeWeight: 6
          });
        } else {
          this.rangePolyline.setPath(path);
          this.rangePolyline.setMap(this.map);
        }
      }
    },
    computeStats(startIdx, endIdx) {
      if (endIdx <= startIdx) return null;
      const pts = this.stats.trackpoints;
      const dist = pts[endIdx][4] - pts[startIdx][4];
      let gain = 0, loss = 0;
      for (let i = startIdx + 1; i <= endIdx; i++) {
        const diff = pts[i][2] - pts[i-1][2];
        if (diff > 0) gain += diff; else if (diff < 0) loss += -diff;
      }
      const avgUp = dist > 0 ? (gain / dist) * 100 : 0;
      const avgDown = dist > 0 ? (loss / dist) * 100 : 0;
      const netRate = avgUp - avgDown;
      const pred = this.formatTime(this.predictedTimeSeconds(dist, netRate));
      return { dist_m: dist, gain_m: gain, loss_m: loss, avg_up: avgUp, avg_down: avgDown, pred_time: pred };
    },
    buildWaypointSegments() {
      const idxs = [0, ...this.waypoints, this.stats.trackpoints.length - 1].sort((a,b) => a - b);
      const segs = [];
      for (let i = 0; i < idxs.length - 1; i++) {
        const stats = this.computeStats(idxs[i], idxs[i+1]);
        if (stats) segs.push(Object.assign({ idx: i + 1 }, stats));
      }
      return segs;
    },
    updateSegments() {
      const segs = this.buildWaypointSegments();
      const container = document.getElementById('waypointStats');
      if (!container) return;
      container.innerHTML = '';
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const headRow = document.createElement('tr');
      headRow.innerHTML = '<th class="label-cell">Name</th>';
      segs.forEach((seg, i) => {
        const startLabel = i === 0 ? 'Start' : `WP${i}`;
        const endLabel = i === segs.length - 1 ? 'Finish' : `WP${i+1}`;
        headRow.innerHTML += `<th>${startLabel}-${endLabel}</th>`;
      });
      thead.appendChild(headRow);
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      const rows = [
        { label: 'Distance', format: seg => `${(seg.dist_m/1000).toFixed(1)} km` },
        { label: 'Elevation Gain', format: seg => `${seg.gain_m.toFixed(1)} m` },
        { label: 'Elevation Loss', format: seg => `${seg.loss_m.toFixed(1)} m` },
        { label: 'Average Up', format: seg => `${seg.avg_up.toFixed(2)} %` },
        { label: 'Average Down', format: seg => `${seg.avg_down.toFixed(2)} %` }
      ];
      rows.forEach(info => {
        const row = document.createElement('tr');
        row.innerHTML = `<td class="label-cell">${info.label}</td>` + segs.map(seg => `<td>${info.format(seg)}</td>`).join('');
        tbody.appendChild(row);
      });
      table.appendChild(tbody);
      container.appendChild(table);
    },
    updateWaypointDataset() {
      if (!this.chart || !this.stats.profile) return;
      const data = this.stats.profile.map((p, idx) => this.waypoints.includes(idx) ? p[1] : null);
      if (this.chart.data.datasets.length === 1) {
        this.chart.data.datasets.push({ label: 'Waypoints', data, borderColor: 'red', backgroundColor: 'red', showLine: false, pointRadius: 4 });
      } else {
        this.chart.data.datasets[1].data = data;
      }
      this.chart.update();
    },
    loadPredefinedWaypoints() {
      (this.stats.waypoints || []).forEach(wp => {
        const idx = this.nearestIndex(wp.lat, wp.lon);
        this.addWaypoint(idx);
      });
    },
    addWaypoint(idx) {
      if (idx <= 0 || idx >= this.stats.trackpoints.length - 1) return;
      if (!this.waypoints.includes(idx)) {
        this.waypoints.push(idx);
        this.waypoints.sort((a,b) => a-b);
        if (this.map) {
          const marker = new google.maps.Marker({ position: { lat: this.stats.trackpoints[idx][0], lng: this.stats.trackpoints[idx][1] }, map: this.map, label: String(this.waypoints.indexOf(idx)+1) });
          this.wpMarkers.push(marker);
        }
        this.updateSegments();
        this.updateWaypointDataset();
      }
    },
    clearWaypoints() {
      this.waypoints = [];
      this.wpMarkers.forEach(m => m.setMap(null));
      this.wpMarkers = [];
      this.updateSegments();
      this.updateWaypointDataset();
    },
    generateAnalysis() {
      this.analysisText = 'Generating...';
      fetch('/generate-analysis', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ stats: this.stats })
      })
        .then(res => res.json())
        .then(data => {
          if (data.text) this.analysisText = marked.parse(data.text);
          else this.analysisText = 'Failed to generate';
        })
        .catch(() => { this.analysisText = 'Error generating analysis'; });
    },
    onKmRowClick(_e, row) {
      if (row.start_idx != null && row.end_idx != null) {
        this.highlightRange(row.start_idx, row.end_idx);
      }
    }
  }
}).use(vuetify).mount('#app');
</script>
<% if (googleMapsApiKey) { %>
<script async defer src="https://maps.googleapis.com/maps/api/js?key=<%= googleMapsApiKey %>"></script>
<% } %>
</body>
</html>
